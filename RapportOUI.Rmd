---
title: "Rapport de projet - Analyse de données"
author: "ALIX Claire - ZEGHARI Saad"
institute : "INSA Toulouse"
date: "`r Sys.Date()`"
output: 
  pdf_document :
    toc : TRUE
    toc_depth : 3
    number_section : TRUE
geometry: margin=0.7in
header-includes:
   - \usepackage{dsfont}
   - \usepackage{color}
   - \newcommand{\1}{\mathds{1}}
---

```{r setup, include=FALSE }
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning=FALSE,fig.align="center",fig.width=15,fig.height = 6, dpi=300)

#importation des packages utiles au projet
library(reticulate)
library(ggplot2)
library(corrplot)
library(FactoMineR)
library(factoextra)
library(gridExtra)
library(BioStatR)
library(reshape2)
library(forcats)
library(mclust)
library(cluster)
library(ppclust)
library(circlize)
library(ggalluvial)
library(clusterSim)
library(seriation)
library(knitr)

```
# Introduction

Dans ce projet, on s'intéresse à la population des gènes d'une plante modèle. On souhaite analyser un jeu de données représentant les différences d'expression d'un certain nombre de gènes pour plusieurs traitements appliqués et en tirer des conclusions pertinentes à propos l'expérience biologique menée.

Tout au long de ce rapport, le symbole {\textbf{\textsf{R}}} indique que des informations dans le code ne sont pas transmises dans le rapport.

# Statistiques descriptives

## Description du jeu de données

```{r,eval=T, echo=FALSE}
#On récupère le jeu de données
data<-read.table("DataProjet3MIC-2425.txt",header=T, sep=";", stringsAsFactors = T)
```
Afin de décrire l'ensemble du jeu de données, nous avons utilisé quelques commandes {\textbf{\textsf{R}}}.
```{r,eval=T, echo=FALSE, results='hide'}
#commandes utiles pour l'analyse du jeu de données
head(data)
str(data)
names(data)
colnames(data)
attributes(data)
```
Le jeu de données fourni est composé d'un échantillon de 542 individus qui correspondent aux gènes de la plante modèle et comporte 39 variables statistiques qui caractérisent les individus. 

Grace à la commande `str(data)`, on observe que les 36 premières variables sont des variables quantitatives continues (variables nommées Tt_sh_Rr). Ces variables permettent d'évaluer les divergences d'expression des gènes pour trois traitements appliqués (T1, T2 et T3) par rapport à un état sans traitement de référence. Les données de chaque traitement ont été relevées durant 6 heures et ceci pour deux réplicats biologiques (R1 et R2).

Les trois dernières variables (nommées ExpT1, ExpT2 et ExpT3) sont des variables qualitatives nominales/ordinales dont les trois modalités sont : "Non", "Sous" et "Sur". Ces dernières représentent la décision si le gène est sur-exprimé, sous-exprimé ou non-exprimé à 6 heures par rapport à l'état de référence, pour chaque traitement.

Afin de visualiser les données, les premières lignes du jeu de données sont affichées dans la Table \ref{tab:tabdata}. 
En raison de la grande quantité de données, nous avons choisi de représenter seulement les variables T1_1h_R1 à T1_6h_R1 et ExpT1 qui donnent un aperçu de la structure du jeu de données pour le réplicat 1.

```{r, echo=FALSE, eval=TRUE}
kable(head(data[,c(1:6,37)]),caption="\\label{tab:tabdata}Les premières lignes du jeu de données.")
```

## Analyse uni-dimensionnelle

Nous commençons par faire quelques statistiques descriptives uni-dimensionnelles et bi-dimensionnelles afin de prendre en main le jeu de données.

### Variables qualitatives

```{r echo=FALSE, eval=FALSE}
#Visualisation des modalités des trois variables qualitatives
levels(data$ExpT1)
levels(data$ExpT2)
levels(data$ExpT3)
```

Nous avons à notre disposition trois variables qualitatives : ExpT1, ExpT2, ExpT3 comme décrites précédemment {\textbf{\textsf{R}}}. Pour extraire certaines tendances des traitements appliqués, nous analysons les fréquences d'apparition des différentes modalités et nous les représentons sous forme de diagrammes en secteurs dans la Figure \ref{fig:diagsecteurs}.

```{r ,echo=F, eval=FALSE}
#Tableau des fréquences pour les variables qualitatives (non utilisé dans le rapport)

Eff1<-table(data$ExpT1)
#df1<-data.frame(Eff1=c(Eff1),Freq=c(Eff1)/sum(Eff1))
#knitr::kable(t(df1))

Eff2<-table(data$ExpT2)
#df2<-data.frame(Eff2=c(Eff2),Freq=c(Eff2)/sum(Eff2))
#knitr::kable(t(df2))

Eff3<-table(data$ExpT3)
#df3<-data.frame(Eff3=c(Eff3),Freq=c(Eff3)/sum(Eff3))
#knitr::kable(t(df3))

#On regroupe les trois variables dans un même tableau pour pouvoir comparer les traitements
df<-data.frame(ExpT1=round(c(Eff1)*100/sum(Eff1),digits = 3), ExpT2=round(c(Eff2)*100/sum(Eff2),digits=3), ExpT3=round(c(Eff3)*100/sum(Eff3),digits=3))
knitr::kable(t(df),caption="\\label{tab:tabfreq}Tableau des fréquences pour les variables qualitatives (en %)")
```

```{r, echo=FALSE, eval=FALSE}
#barplots des effectifs des variables qualitatives (non utilisé dans le rapport)
g1 = ggplot(data) + geom_bar(aes(x = ExpT1)) 
g2 = ggplot(data) + geom_bar(aes(x = ExpT2)) 
g3 = ggplot(data) + geom_bar(aes(x = ExpT3)) 
grid.arrange(g1,g2,g3,ncol=3)
```

```{r, echo=FALSE, eval=TRUE, fig.align='center', fig.cap="\\label{fig:diagsecteurs}Diagrammes en secteurs des fréquences des variables ExpT1, ExpT2 et ExpT3"}
#Diagrammes en secteurs des fréquences pour les variables qualitatives

#Pour ExpT1
df1 <- data.frame(group = levels(data$ExpT1), value = as.vector(table(data$ExpT1)) / nrow(data))
g1pie <- ggplot(df1, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7),  
            size = 6, family = "serif", fontface = "bold") +  #Changer la police
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_line(color = "gray"),  #Lignes de la grille visibles
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, family = "serif", size = 20, face = "bold")  #Centrer et styliser le titre
  ) +
  labs(fill = NULL) +
  ggtitle("ExpT1") 

#Pour ExpT2
df2 <- data.frame(group = levels(data$ExpT2), value = as.vector(table(data$ExpT2)) / nrow(data))
g2pie <- ggplot(df2, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7), 
            size = 6, family = "serif", fontface = "bold") +  #Changer la police
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_line(color = "gray"),  #Lignes de la grille visibles
    axis.text.y = element_text(size = 10),       #Indicateurs autour du graphique
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, family = "serif", size = 20, face = "bold")  #Centrer et styliser le titre
  ) +
  labs(fill = NULL) +
  ggtitle("ExpT2") 

#Pour ExpT3
df3 <- data.frame(group = levels(data$ExpT3), value = as.vector(table(data$ExpT3)) / nrow(data))
g3pie <- ggplot(df3, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7), 
            size = 6, family = "serif", fontface = "bold") +  # Changer la police
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_line(color = "gray"),  #Lignes de la grille visibles
    axis.text.y = element_text(size = 10),
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, family = "serif", size = 20, face = "bold")  #Centrer et styliser le titre
  ) +
  labs(fill = NULL) +
  ggtitle("ExpT3") 

#Disposition des graphiques
grid.arrange(g1pie, g2pie, g3pie, ncol = 3)

```
D'après la Figure \ref{fig:diagsecteurs}, on peut déjà remarquer que les traitements diffèrent dans la réaction des gènes. En effet, on observe une grande similarité entre les traitements 2 et 3 avec des réactions réparties de façon quasi-homogène entre les modalités "sous" et "sur" exprimé. Pour sa part, le traitement 1 n'a aucun effet sur la majorité des gènes, qui n'expriment pas de différence particulière par rapport à l'état de référence (81% de "non" exprimé pour ExpT1).


### Variables quantitatives

Nous analysons maintenant les variables quantitatives de notre jeu de données (variables Tt_sh_Rr) individuellement. 

Pour apréhender les différences entre les variables quantitatives et en raison du grand nombre de variables à analyser, nous avons décidé de tracer leurs boxplots respectifs, regroupés par variables d'un même réplicat dans la Figure \ref{fig:boxplots_quantitatives1} et la Figure \ref{fig:boxplots_quantitatives2}. Ceci nous permet de résumer les variables de manière simple et visuelle, d'identifier les valeurs extrêmes, comprendre la répartition des observations et de comparer les deux réplicats ensemble ainsi que les traitements et les heures d'observation. 

Faire tous les codes qu'on utilisera pas dans le rapport (ex histogrammes, moyennes, variances...)

```{r,echo=F, fig.align="center", fig.cap="\\label{fig:boxplots_quantitatives1}Boxplots des variables quantitatives du réplicat R1"}
#On sépare les boxplots des deux réplicats pour avoir des graphiques plus lisibles et comparables
data1 <- melt(data[, -c(19:39)])
ggplot(data1, aes(x = variable, y = value)) + geom_boxplot()
```

```{r,echo=F, fig.align="center", fig.cap="\\label{fig:boxplots_quantitatives2}Boxplots des variables quantitatives du réplicat R2"}
data2 <- melt(data[, -c(1:18,37:39)])
ggplot(data2, aes(x = variable, y = value)) + geom_boxplot()
```

Lorsque l'on compare les Figures 2 et 3, on peut observer que les résultats des deux réplicats se ressemblent entre eux

Nous pouvons ainsi comparer les médianes et les écarts interquartiles respectifs des variables pour évaluer la dispertion.
Cependant, les séries statistiques sont très variables. On observe par exemple la variable ... a une plus grande variance que la variable ...

Résultat pour l'ACP

Valeurs aberrantes/extremes
comparer des variables basées sur des échelles similaires


## Analyse bi-dimensionnelle

BLALABLA

### Une variable qualitative et une variable quantitative

BLOBLOBLO
```{r, fig.align='center', fig.cap="boxplots parallèles"}
#On a regardé ça avec Tessa, pas sures de son utilité mais y'a moyen de trouver une interprétation logique avec les différences entre les différents boxplots

plot1<-ggplot(data,aes(x=ExpT1,y=T1_6H_R1 ))+geom_boxplot()
plot2<-ggplot(data,aes(x=ExpT2,y=T2_6H_R1))+geom_boxplot()
plot3<-ggplot(data,aes(x=ExpT3,y=T3_6H_R1 ))+geom_boxplot()
plot4<-ggplot(data,aes(x=ExpT1,y=T1_6H_R2 ))+geom_boxplot()
plot5<-ggplot(data,aes(x=ExpT2,y=T2_6H_R2))+geom_boxplot()
plot6<-ggplot(data,aes(x=ExpT3,y=T3_6H_R2 ))+geom_boxplot()
grid.arrange(plot1,plot2,plot3,plot4,plot5,plot6,ncol=6)
```
### Deux variables qualitatives

```{r,fig.cap="\\label{fig:boxplots} Tableaux de contingence des variables qualitatives"}
#prop.table(table(data$ExpT1,data$ExpT2),margin=1)
g1<-ggplot(data,aes(x=ExpT1,fill=ExpT2))+
geom_bar(position = "fill")

#prop.table(table(data$ExpT1,data$ExpT3),margin=1)
g2<-ggplot(data,aes(x=ExpT1,fill=ExpT3))+
geom_bar(position = "fill")

#prop.table(table(data$ExpT2,data$ExpT3),margin=1)
g3<-ggplot(data,aes(x=ExpT2,fill=ExpT3))+
geom_bar(position = "fill")

grid.arrange(g1,g2,g3,ncol=3)

#mosaicplot(table(data$ExpT1,data$ExpT2)) #illisible
#mosaicplot(table(data$ExpT1,data$ExpT3))
```

### Deux variables quantitatives

BLUBLUBLU
```{r ,echo=F,fig.align = "center", fig.cap="matrice des corrélations"}
corrplot(cor(data[, -c(37:39)]), method = "ellipse")
```

# Analyse des Tt_sh_Rr

## Analyse en composantes principales

Menez une analyse en composantes principales où les Tt_sH_Rr sont les individus d´ecrits par les
gènes.
Pour savoir si utilise l'ACP centrée ou l'ACP centrée reduite, on compare les pourcentages des variances cumulées sur les deux ACP. Car on ne peut pas utiliser des boxplots pour le déterminer (trop de variables)

```{r,echo=FALSE, eval=T}
dataACPv<-t(data[c(1:36)]) #on retire les variables qualitatives et on transpose le dataframe 
dim(dataACPv) #on vérifie les bonnes dimensions du jeu de données

#ACP centrée
resacpa<-PCA((dataACPv),scale.unit = F,graph=F)
resacpa$eig[1:3,]
```

```{r, echo=FALSE, eval=TRUE}
#ACP centrée réduite
respcav<-PCA((dataACPv),scale.unit = T,graph=F)
respcav$eig[1:3,]
fviz_eig(respcav)
```

Par convention, on souhaite récuperer au minimum 80% de la variance. Avec deux composantes, l'ACP centrée réduite permet de récupérer plus d'information que l'ACP centréé (81,6% contre 80,5%)

```{r,eval=T}
#graphe des variables
fviz_pca_var(respcav) #graphique des corrélations entre les variables initiales et les méta-variables => Illisible

#graphe des individus
fviz_pca_ind(respcav,col.ind="contrib",geom=c("point"))

```
Graphe variable => Illisible (rien conclure quant aux variables car bcp trop nombreuses)
=> On fait une analyse séparée (voit graphe du dessous)

Graphe individu => Pas un regroupement spécifique, on a 2/3. On a une variabilité des réaction en fonction des spécifités des individus.


PARLER DE L'INERTIE
```{r}
#Habillages sur le graphe des individus

#réplicat 1 en bleu et réplicat 2 en rouge 
colors <- rep("red", nrow(dataACPv))
colors[1:18] <- "blue"
fviz_pca_ind(respcav, geom = c("point"), col.ind = colors) +
  scale_color_manual(values = c("blue" = "blue", "red" = "red"), 
                     labels = c("R1", "R2")) +
  labs(color = "Réplicats")
```
Les points R1 et R2 sont répartis equitablement entre Dim1 et Dim2 (autant d'individus de chaque côté des axes)
Ce mélange/chevauchement indique que la variabilité n'est pas entièrement due aux différents réplicaentre les 2 réplicats : aucun des réplicats n'est dominant => D'autres facteurs comme le traitement ou les heures.
```{r}
#en fonction des traitement 
colors <- rep("red", nrow(dataACPv))
colors[c(1:6,19:25)] <- "blue"
colors[c(7:12,26:32)] <- "green"
fviz_pca_ind(respcav, geom = c("point"), col.ind = colors) +
  scale_color_manual(values = c("blue" = "blue", "green" = "green", "red" = "red"), 
                     labels = c("T1", "T2", "T3")) +
  labs(color = "Traitements")
```
T1 sont prinipalement à gauche du graphique (avec un léger mélange). T2 et T3 sont beaucoup plus mélangés à droite. Cela appuie que les effets du traitement 1 sont diffrents de ceux de T2 et T3 (qui se ressemblent plus)

```{r}
#en fonction des heures
colors <- rep("red", nrow(dataACPv))
colors[c(1,7,13,19,25,31)] <- "blue"    # Heure 1
colors[c(2,8,14,20,26,32)] <- "green"   # Heure 2
colors[c(3,9,15,21,27,33)] <- "purple"  # Heure 3
colors[c(4,10,16,22,28,34)] <- "yellow" # Heure 4
colors[c(5,11,17,23,29,35)] <- "orange" # Heure 5

fviz_pca_ind(respcav, geom = c("point"), col.ind = colors) +
  scale_color_manual(values = c("blue" = "blue", "green" = "green", "purple" = "purple", 
                                "yellow" = "yellow", "orange" = "orange", "red" = "red"),
                     labels = c("Heure 1", "Heure 2", "Heure 3", "Heure 4", "Heure 5", "Heure 6")) +
  labs(color = "Heures")

```
Heure 1 => Ttes à droites quelque soit le traitement appliqué
Heure 2 => Tratement 1 à gauche et T2/T3 à droite

## Clustering

### Détermination du nombre de classes


```{r}
#Inertie intraclasse

Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(dataACPv),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
  resaux<-kmeans(dataACPv,k)
  reskmeanscl[,k-1]<-resaux$cluster
  Iintra<-c(Iintra,resaux$tot.withinss)
}

df<-data.frame(K=2:15,Iintra=Iintra)
g1<-ggplot(df,aes(x=K,y=Iintra))+
  geom_line()+
  geom_point()+
  xlab("Nombre de classes")+
  ylab("Inertie intraclasse") 
  #ggtitle("Figure 9.1: Inertie intraclasse")
```


```{r}
#silhouette

Silhou<-NULL
for (k in 2:Kmax){
   aux<-silhouette(reskmeanscl[,k-1], daisy(dataACPv))
   Silhou<-c(Silhou,mean(aux[,3]))
}

df<-data.frame(K=2:Kmax,Silhouette=Silhou)
g2<-ggplot(df,aes(x=K,y=Silhouette))+
  geom_point()+
  geom_line()+theme(legend.position = "bottom")
# ggtitle("Figure 10 : Coefficients silhouette")

aux<-silhouette(reskmeanscl[,3],daisy(dataACPv))
g3<-fviz_silhouette(aux)+
  theme(plot.title = element_text(size =9)) 
#+ ggtitle("Figure 11 : Visualisation des silhouettes")
rm(df,Silhou,aux)

g1 <- g1 + ggtitle("Figure 9.1: Inertie intraclasse") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))
g2 <- g2 + ggtitle("Figure 9.2: Coefficients silhouettes") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))
g3 <- g3 + ggtitle("Figure 9.3 : Visualisation des silhouettes") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))

grid.arrange(g1,g2,g3,ncol=3)
```

Blablabla on choisi 3/4 classes parce que...

### Kmeans

```{r,echo=F,eval=T}
reskmeans<-kmeans(dataACPv,3) 
```


```{r,eval=F}
fviz_cluster(reskmeans,data=dataACPv,
             ellipse.type="norm",labelsize=8,
             geom=c("point"))+ggtitle("")

fviz_pca_ind(respcav,col.ind=as.factor(reskmeans$cluster),
             geom = c("point"),axes=c(1,2))
```
Interprétation Kmeans

Il faut regarder ce qu'il y a dans reskmeans$cluster pour voir qu'elle variable va dans quelle classe et commenter 

On ne compare pas avec les variables qualitatives car il n'y en a pas 

### Classification hiérarchique

```{r}
# dendogramme
dist_dataACPv = dist(dataACPv)

hward<-hclust(dist_dataACPv, method = "ward.D2") 
fviz_dend(hward,show_labels=FALSE)
```
```{r ,fig.cap="A compléter v"}
# A COMPLETER
CH<-NULL
Kmax<-20
for (k in 2:Kmax){
  CH<-c(CH,index.G1(dataACPv, cl= cutree(hward,k)))
}
#On prend k = 3
daux<-data.frame(NbClust=2:Kmax,CH=CH)
g1<-ggplot(daux,aes(x=NbClust,y=CH))+
  geom_line()+
  geom_point()

ClustCH<-cutree(hward,k=3)
g2<-fviz_dend(hward, show_labels = FALSE, k = 3)
g3<-fviz_pca_ind(respcav, geom = c("point"), habillage = as.factor(ClustCH)) 

grid.arrange(g1,g2,g3,ncol=3)
```

# Analyse des gènes

Construisez un jeu de données DataExpMoy contenant la moyenne des expressions sur les réplicats de chaque gène, pour chaque traitement et chaque heure. DataExpMoy est donc une matrice de taille G × 18. Vous pourrez utiliser les variables ExpT1, ExpT2 et ExpT3 pour commenter vos résultats des questions suivantes.

## Analyse en composantes principales

```{r}
#Création du jeu de données DataExpMoy
dataR1<-data[,1:18]
dataR2<-data[,19:36]
dataACPg<-(dataR1+dataR2)/2
dim(dataACPg) #on a bien Gx18

#On ajoute les variables qualitatives
dataACPg<-cbind(dataACPg, ExpT1=data$ExpT1, ExpT2=data$ExpT2, ExpT3=data$ExpT3)
dim(dataACPg)
```
Expliquer avec les boxplots pourquoi on fait l'ACP centrée réduite
```{r,eval=T}
#ACP Centrée réduite
respcag<-PCA(dataACPg,quali.sup=c(19,20,21),scale.unit = TRUE,graph=F)
respcag$eig[1:5,]
fviz_eig(respcag)

```
Les deux premieres composantes pricipales regroupent plus de 80% de variances (81,4% avec ACP centrée reduite).


```{r,eval=F}
fviz_pca_var(respcag) #graphique des corrélations entre les variables initiales et les méta-variables => Illisible

corrplot(respcag$var$cor,method="ellipse")  #les corrélations des variables initiales avec toutes les méta-variables => Plus lisible (même si c pas ouf)

fviz_pca_ind(respcag,col.ind="contrib",geom=c("point"))
```


## Clustering

```{r}
dataACPgC<-scale(dataACPg[,-c(19,20,21)] ,center=TRUE,scale=TRUE)

Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(dataACPg),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
  resaux<-kmeans(dataACPgC,k)
  reskmeanscl[,k-1]<-resaux$cluster
  Iintra<-c(Iintra,resaux$tot.withinss)
}

df<-data.frame(K=2:15,Iintra=Iintra)
g1<-ggplot(df,aes(x=K,y=Iintra))+
  geom_line()+
  geom_point()+
  xlab("Nombre de classes")+
  ylab("Inertie intraclasse")

```

```{r}
# Silhouette 

Silhou<-NULL
for (k in 2:Kmax){
   aux<-silhouette(reskmeanscl[,k-1], daisy(dataACPgC))
   Silhou<-c(Silhou,mean(aux[,3]))
}

df<-data.frame(K=2:Kmax,Silhouette=Silhou)
g2<-ggplot(df,aes(x=K,y=Silhouette))+
  geom_point()+
  geom_line()+theme(legend.position = "bottom")

aux<-silhouette(reskmeanscl[,3],daisy(dataACPgC))
g3<-fviz_silhouette(aux)+
  theme(plot.title = element_text(size =9))
rm(df,Silhou,aux)


grid.arrange(g1,g2,g3,ncol=3)
```

### Kmeans

```{r,echo=F,eval=T}
reskmeans<-kmeans(dataACPgC,3) 
```


```{r,eval=F}
fviz_cluster(reskmeans,data=dataACPgC,
             ellipse.type="norm",labelsize=8,
             geom=c("point"))+ggtitle("")

fviz_pca_ind(respcag,col.ind=as.factor(reskmeans$cluster),
             geom = c("point"),axes=c(1,2))
```




### Classification hiérarchique

```{r}
# dendogramme
dist_dataACPg = dist(dataACPgC)

hward<-hclust(dist_dataACPg, method = "ward.D2") 
fviz_dend(hward,show_labels=FALSE)
```


```{r}
# A COMPLETER
CH<-NULL
Kmax<-20
for (k in 2:Kmax){
  CH<-c(CH,index.G1(dataACPgC, cl= cutree(hward,k)))
}
#On prend k = 3
daux<-data.frame(NbClust=2:Kmax,CH=CH)
g1<-ggplot(daux,aes(x=NbClust,y=CH))+
  geom_line()+
  geom_point()

ClustCH<-cutree(hward,k=3)
g2<-fviz_dend(hward, show_labels = FALSE, k = 3)
g3<-fviz_pca_ind(respcag, geom = c("point"), habillage = as.factor(ClustCH)) 

grid.arrange(g1,g2,g3,ncol=3)
```

```{r}
clust1<-paste("Cl-K",reskmeans$cluster,sep="")
clust2<-paste("Cl-hiérarchique",ClustCH,sep="")
Tab<-melt(table(clust1,clust2))
ggplot(Tab,aes(y=value,axis1=clust1,axis2=clust2))+
  geom_alluvium(aes(fill=clust1))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure 15.2")
  theme(legend.position = "none")
```

## Clustering 2 (comparaison avec variable qualitatives) 

```{r}
g1<-fviz_pca_ind(respcag,habillage="ExpT1",geom=c("point"))
g2<-fviz_pca_ind(respcag,habillage="ExpT2",geom=c("point"))
g3<-fviz_pca_ind(respcag,habillage="ExpT3",geom=c("point"))
grid.arrange(g1,g2,g3,ncol=3)

```

```{r}
clust<-paste("Cl-K",reskmeans$cluster,sep="")
Tab<-melt(table(clust,dataACPg[,19]))
g1<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("Figure 15.3")+
  theme(legend.position = "none")
```


```{r}
clust<-paste("Cl-K",reskmeans$cluster,sep="")
Tab<-melt(table(clust,dataACPg[,20]))
g2<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure15.1 a completer")
  theme(legend.position = "none")

```

```{r}
clust<-paste("Cl-K",reskmeans$cluster,sep="")
Tab<-melt(table(clust,dataACPg[,21]))
g3<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure 15.2")
  theme(legend.position = "none")
grid.arrange(g1,g2,g3,ncol=3)

```
```{r}
clust<-paste("Cl-hiérarchique",ClustCH,sep="")
Tab<-melt(table(clust,dataACPg[,19]))
g1<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("Figure 15.3")+
  theme(legend.position = "none")
```


```{r}
clust<-paste("Cl-hiérarchique",ClustCH,sep="")
Tab<-melt(table(clust,dataACPg[,20]))
g2<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure15.1 a completer")
  theme(legend.position = "none")

```

```{r}
clust<-paste("Cl-hiérarchique",ClustCH,sep="")
Tab<-melt(table(clust,dataACPg[,21]))
g3<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure 15.2")
  theme(legend.position = "none")
grid.arrange(g1,g2,g3,ncol=3)

```
