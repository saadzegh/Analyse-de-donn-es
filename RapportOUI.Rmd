---
title: "Rapport de projet - Analyse de données"
author: "ALIX Claire - ZEGHARI Saad"
institute : "INSA Toulouse"
date: "`r Sys.Date()`"
output: 
  pdf_document :
    toc : TRUE
    toc_depth : 3
    number_section : TRUE
geometry: margin=0.7in
header-includes:
   - \usepackage{dsfont}
   - \usepackage{color}
   - \newcommand{\1}{\mathds{1}}
---

```{r setup, include=FALSE }
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning=FALSE,fig.align="center",fig.width=15,fig.height = 6, dpi=300)

#importation des packages utiles au projet
library(reticulate)
library(ggplot2)
library(corrplot)
library(FactoMineR)
library(factoextra)
library(gridExtra)
library(BioStatR)
library(reshape2)
library(forcats)
library(mclust)
library(cluster)
library(ppclust)
library(circlize)
library(ggalluvial)
library(clusterSim)
library(seriation)
library(knitr)

```
# Introduction

Dans ce projet, on s'intéresse à la population des gènes d'une plante modèle. On souhaite analyser un jeu de données représentant les différences d'expression d'un certain nombre de gènes pour plusieurs traitements appliqués et en tirer des conclusions pertinentes à propos l'expérience biologique menée.

# Statistiques descriptives

## Description du jeu de données

```{r,eval=T, echo=FALSE}
#On récupère le jeu de données
data<-read.table("data.txt",header=T, sep=";", stringsAsFactors = T)
```

```{r,eval=T, echo=FALSE, results='hide'}
#commandes utiles pour l'analyse du jeu de données
head(data)
str(data)
names(data)
colnames(data)
attributes(data)
```
Le jeu de données fourni est composé d'un échantillon de 542 individus qui correspondent aux gènes de la plante modèle et comporte 39 variables statistiques qui caractérisent les individus. 

Grace à la commande `str(data)`, on observe que les 36 premières variables sont des variables quantitatives continues (variables nommées Tt_sh_Rr). Ces variables permettent d'évaluer les divergences d'expression des gènes pour trois traitements appliqués (T1, T2 et T3) par rapport à un état sans traitement de référence. Les données de chaque traitement ont été relevées durant 6 heures et ceci pour deux réplicats biologiques (R1 et R2).

Les trois dernières variables (nommées ExpT1, ExpT2 et ExpT3) sont des variables qualitatives nominales/ordinales dont les trois modalités sont : "Non", "Sous" et "Sur". Ces dernières représentent la décision si le gène est sur-exprimé, sous-exprimé ou non-exprimé à 6 heures par rapport à l'état de référence, pour chaque traitement.

Afin de visualiser les données, les premières lignes du jeu de données sont affichées dans la Table \ref{tab:tabdata}. 
En raison de la grande quantité de données, nous avons choisi de représenter seulement les variables T1_1h_R1 à T1_6h_R1 et ExpT1 qui donnent un aperçu de la structure du jeu de données pour le réplicat 1.

```{r, echo=FALSE, eval=TRUE}
kable(head(data[,c(1:6,37)]),caption="\\label{tab:tabdata}Les premières lignes du jeu de données.")
```

## Analyse uni-dimensionnelle

Nous commençons par faire quelques statistiques descriptives uni-dimensionnelles et bi-dimensionnelles afin de prendre en main le jeu de données.

### Variables qualitatives

Nous avons à notre disposition trois variables qualitatives : ExpT1, ExpT2, ExpT3 comme décrites précédemment. Pour extraire certaines tendances des traitements appliqués, nous analysons les fréquences d'apparition des différentes modalités et nous les représentons sous forme de diagramme en secteur dans la figure 1.

```{r echo=FALSE, eval=FALSE}
#Visualisation des modalités des trois variables qualitatives
levels(data$ExpT1)
levels(data$ExpT2)
levels(data$ExpT3)
```

```{r ,echo=F, eval=FALSE}
#Tableau des fréquences pour les variables qualitatives

Eff1<-table(data$ExpT1)
#df1<-data.frame(Eff1=c(Eff1),Freq=c(Eff1)/sum(Eff1))
#knitr::kable(t(df1))

Eff2<-table(data$ExpT2)
#df2<-data.frame(Eff2=c(Eff2),Freq=c(Eff2)/sum(Eff2))
#knitr::kable(t(df2))

Eff3<-table(data$ExpT3)
#df3<-data.frame(Eff3=c(Eff3),Freq=c(Eff3)/sum(Eff3))
#knitr::kable(t(df3))

#On regroupe les trois variables dans un même tableau pour pouvoir comparer les traitements
df<-data.frame(ExpT1=round(c(Eff1)*100/sum(Eff1),digits = 3), ExpT2=round(c(Eff2)*100/sum(Eff2),digits=3), ExpT3=round(c(Eff3)*100/sum(Eff3),digits=3))
knitr::kable(t(df),caption="\\label{tab:tabfreq}Tableau des fréquences pour les variables qualitatives (en %)")
```

```{r, echo=FALSE, eval=FALSE}
#barplots des effectifs des variables qualitatives (non utilisés dans le rapport)
g1 = ggplot(data) + geom_bar(aes(x = ExpT1)) 
g2 = ggplot(data) + geom_bar(aes(x = ExpT2)) 
g3 = ggplot(data) + geom_bar(aes(x = ExpT3)) 

grid.arrange(g1,g2,g3,ncol=3)
```

```{r, echo=FALSE, eval=TRUE, fig.align='center', fig.cap="Diagramme en secteur"}
#Diagrammes en secteurs des fréquences pour les variables qualitatives

# Pour ExpT1
df1 <- data.frame(group = levels(data$ExpT1), value = as.vector(table(data$ExpT1)) / nrow(data))
g1pie <- ggplot(df1, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7),  
            size = 6, family = "serif", fontface = "bold") +  #Changer la police
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_line(color = "gray"),  #Lignes de la grille visibles
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, family = "serif", size = 20, face = "bold")  # Centrer et styliser le titre
  ) +
  labs(fill = NULL) +
  ggtitle("ExpT1") 

#Pour ExpT2
df2 <- data.frame(group = levels(data$ExpT2), value = as.vector(table(data$ExpT2)) / nrow(data))
g2pie <- ggplot(df2, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7), 
            size = 6, family = "serif", fontface = "bold") +  #Changer la police
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_line(color = "gray"),  #Lignes de la grille visibles
    axis.text.y = element_text(size = 10),       #Indicateurs autour du graphique
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, family = "serif", size = 20, face = "bold")  #Centrer et styliser le titre
  ) +
  labs(fill = NULL) +
  ggtitle("ExpT2") 

#Pour ExpT3
df3 <- data.frame(group = levels(data$ExpT3), value = as.vector(table(data$ExpT3)) / nrow(data))
g3pie <- ggplot(df3, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7), 
            size = 6, family = "serif", fontface = "bold") +  # Changer la police
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_line(color = "gray"),  # Lignes de la grille visibles
    axis.text.y = element_text(size = 10),
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, family = "serif", size = 20, face = "bold")  #Centrer et styliser le titre
  ) +
  labs(fill = NULL) +
  ggtitle("ExpT3") 

#Disposition des graphiques
grid.arrange(g1pie, g2pie, g3pie, ncol = 3)

```
D'après la figure 1, on peut déjà remarquer que les traitements diffèrent dans la réaction des gènes. En effet, on observe une grande similarité entre les traitements 2 et 3 avec des réactions réparties de façon homogène entre "sous" et "sur" exprimé. Pour sa part, le traitement 1 n'a aucun effet sur la majorité des gènes, qui n'expriment pas de différence particulière par rapport à l'état de référence (81% de "non" exprimé).


### Variables quantitatives

Nous analysons maintenant les variables quantitatives de notre jeu de données (variables Tt_sh_Rr) individuellement. 

Pour apréhender les différences entre les variables quantitatives, leurs boxplots ont été tracés dans la Figure 2 et la Figure 3. Resumer les variables de manière simple et visuelle, identifier les valeurs extremes et comprendre la répartition des observations

comparer des variables basées sur des échelles similaires

Comme nous avons 36 variables quantitatives, nous avons décidé de séparer les variables en deux graphiques qui représentent les deux réplicats. Nous pouvons ainsi comparer les médianes et les écarts interquartiles respectifs des variables pour évaluer la dispertion.

Faire tous les codes qu'on utilisera pas dans le rapport (ex histogrammes, moyennes, variances...)

```{r,echo=F, fig.align="center", fig.cap="Boxplots des variables quantitatives du réplicat R1"}
#On sépare le sboxplots des deux réplicats pour avoir des graphiques plus lisibles
data1 <- melt(data[, -c(19:39)])
ggplot(data1, aes(x = variable, y = value)) + geom_boxplot()
```

```{r,echo=F, fig.align="center", fig.cap="Boxplots des variables quantitatives du réplicat R2"}
data2 <- melt(data[, -c(1:18,37:39)])
ggplot(data2, aes(x = variable, y = value)) + geom_boxplot()
```
Lorsque l'on compare les Figures 2 et 3, on peut observer que les résultats des deux réplicats se ressemblent entre eux

Cependant, les séries statistiques sont très variables. On observe par exemple la variable ... a une plus grande variance que la variable ...

Résultat pour l'ACP

Valeurs aberrantes/extremes


## Analyse bi-dimensionnelle

BLALABLA

### Une variable qualitative et une variable quantitative

BLOBLOBLO
```{r, fig.align='center', fig.cap="boxplots parallèles"}
#On a regardé ça avec Tessa, pas sures de son utilité mais y'a moyen de trouver une interprétation logique avec les différences entre les différents boxplots

plot1<-ggplot(data,aes(x=ExpT1,y=T1_6H_R1 ))+geom_boxplot()
plot2<-ggplot(data,aes(x=ExpT2,y=T2_6H_R1))+geom_boxplot()
plot3<-ggplot(data,aes(x=ExpT3,y=T3_6H_R1 ))+geom_boxplot()
plot4<-ggplot(data,aes(x=ExpT1,y=T1_6H_R2 ))+geom_boxplot()
plot5<-ggplot(data,aes(x=ExpT2,y=T2_6H_R2))+geom_boxplot()
plot6<-ggplot(data,aes(x=ExpT3,y=T3_6H_R2 ))+geom_boxplot()
grid.arrange(plot1,plot2,plot3,plot4,plot5,plot6,ncol=6)
```
### Deux variables qualitatives

```{r,fig.cap="\\label{fig:boxplots} Tableaux de contingence des variables qualitatives"}
#prop.table(table(data$ExpT1,data$ExpT2),margin=1)
g1<-ggplot(data,aes(x=ExpT1,fill=ExpT2))+
geom_bar(position = "fill")

#prop.table(table(data$ExpT1,data$ExpT3),margin=1)
g2<-ggplot(data,aes(x=ExpT1,fill=ExpT3))+
geom_bar(position = "fill")

#prop.table(table(data$ExpT2,data$ExpT3),margin=1)
g3<-ggplot(data,aes(x=ExpT2,fill=ExpT3))+
geom_bar(position = "fill")

grid.arrange(g1,g2,g3,ncol=3)

#mosaicplot(table(data$ExpT1,data$ExpT2)) #illisible
#mosaicplot(table(data$ExpT1,data$ExpT3))
```

### Deux variables quantitatives

BLUBLUBLU
```{r ,echo=F,fig.align = "center", fig.cap="matrice des corrélations"}
corrplot(cor(data[, -c(37:39)]), method = "ellipse")
```

# Analyse des Tt_sh_Rr

## Analyse en composantes principales

Menez une analyse en composantes principales où les Tt_sH_Rr sont les individus d´ecrits par les
gènes.
Pour savoir si utilise l'ACP centrée ou l'ACP centrée reduite, on compare les pourcentages des variances cumulées sur les deux ACP. Car on ne peut pas utiliser des boxplots pour le déterminer (trop de variables)

```{r,echo=FALSE, eval=T}
dataACPv<-t(data[c(1:36)]) #on retire les variables qualitatives et on transpose le dataframe 
dim(dataACPv) #on vérifie les bonnes dimensions du jeu de données

#ACP centrée
resacpa<-PCA((dataACPv),scale.unit = F,graph=F)
resacpa$eig[1:3,]
```

```{r, echo=FALSE, eval=TRUE}
#ACP centrée réduite
respcav<-PCA((dataACPv),scale.unit = T,graph=F)
respcav$eig[1:3,]
fviz_eig(respcav)
```

Par convention, on souhaite récuperer au minimum 80% de la variance. Avec deux composantes, l'ACP centrée réduite permet de récupérer plus d'information que l'ACP centréé (81,6% contre 80,5%)

```{r,eval=T}
#graphe des variables
fviz_pca_var(respcav) #graphique des corrélations entre les variables initiales et les méta-variables => Illisible

#graphe des individus
fviz_pca_ind(respcav,col.ind="contrib",geom=c("point"))

```
PARLER DE L'INERTIE
```{r}
#Habillages sur le graphe des individus

#réplicat 1 en bleu et réplicat 2 en rouge 
colors <- rep("red", nrow(dataACPv))
colors[1:18] <- "blue"
fviz_pca_ind(respcav, geom = c("point"), col.ind = colors) +
  scale_color_manual(values = c("red", "blue"))

#en fonction des traitement 
colors <- rep("red", nrow(dataACPv))
colors[c(1:6,19:25)] <- "blue"
colors[c(7:12,26:32)] <- "green"
fviz_pca_ind(respcav, geom = c("point"), col.ind = colors)

#en fonction des heures
colors <- rep("red", nrow(dataACPv))
colors[c(1,7,13,19,25,31)] <- "blue"
colors[c(2,8,14,20,26,32)] <- "green"
colors[c(3,9,15,21,27,33)] <- "purple"
colors[c(4,10,16,22,28,34)] <- "yellow"
colors[c(5,11,17,23,29,35)] <- "orange"
#colors[c(6,12,18,24,30,36)] <- "green"
fviz_pca_ind(respcav, geom = c("point"), col.ind = colors)

```

## Clustering

### Détermination du nombre de classes


```{r}
#Inertie intraclasse

Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(dataACPv),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
  resaux<-kmeans(dataACPv,k)
  reskmeanscl[,k-1]<-resaux$cluster
  Iintra<-c(Iintra,resaux$tot.withinss)
}

df<-data.frame(K=2:15,Iintra=Iintra)
g1<-ggplot(df,aes(x=K,y=Iintra))+
  geom_line()+
  geom_point()+
  xlab("Nombre de classes")+
  ylab("Inertie intraclasse") 
  #ggtitle("Figure 9.1: Inertie intraclasse")
```


```{r}
#silhouette

Silhou<-NULL
for (k in 2:Kmax){
   aux<-silhouette(reskmeanscl[,k-1], daisy(dataACPv))
   Silhou<-c(Silhou,mean(aux[,3]))
}

df<-data.frame(K=2:Kmax,Silhouette=Silhou)
g2<-ggplot(df,aes(x=K,y=Silhouette))+
  geom_point()+
  geom_line()+theme(legend.position = "bottom")
# ggtitle("Figure 10 : Coefficients silhouette")

aux<-silhouette(reskmeanscl[,3],daisy(dataACPv))
g3<-fviz_silhouette(aux)+
  theme(plot.title = element_text(size =9)) 
#+ ggtitle("Figure 11 : Visualisation des silhouettes")
rm(df,Silhou,aux)

g1 <- g1 + ggtitle("Figure 9.1: Inertie intraclasse") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))
g2 <- g2 + ggtitle("Figure 9.2: Coefficients silhouettes") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))
g3 <- g3 + ggtitle("Figure 9.3 : Visualisation des silhouettes") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))

grid.arrange(g1,g2,g3,ncol=3)
```

Blablabla on choisi 3/4 classes parce que...

### Kmeans

```{r,echo=F,eval=T}
reskmeans<-kmeans(dataACPv,3) 
```


```{r,eval=F}
fviz_cluster(reskmeans,data=dataACPv,
             ellipse.type="norm",labelsize=8,
             geom=c("point"))+ggtitle("")

fviz_pca_ind(respcav,col.ind=as.factor(reskmeans$cluster),
             geom = c("point"),axes=c(1,2))
```
Interprétation Kmeans

Il faut regarder ce qu'il y a dans reskmeans$cluster pour voir qu'elle variable va dans quelle classe et commenter 

On ne compare pas avec les variables qualitatives car il n'y en a pas 

### Classification hiérarchique

```{r}
# dendogramme
dist_dataACPv = dist(dataACPv)

hward<-hclust(dist_dataACPv, method = "ward.D2") 
fviz_dend(hward,show_labels=FALSE)
```
```{r ,fig.cap="A compléter v"}
# A COMPLETER
CH<-NULL
Kmax<-20
for (k in 2:Kmax){
  CH<-c(CH,index.G1(dataACPv, cl= cutree(hward,k)))
}
#On prend k = 3
daux<-data.frame(NbClust=2:Kmax,CH=CH)
g1<-ggplot(daux,aes(x=NbClust,y=CH))+
  geom_line()+
  geom_point()

ClustCH<-cutree(hward,k=3)
g2<-fviz_dend(hward, show_labels = FALSE, k = 3)
g3<-fviz_pca_ind(respcav, geom = c("point"), habillage = as.factor(ClustCH)) 

grid.arrange(g1,g2,g3,ncol=3)
```

# Analyse des gènes

Construisez un jeu de données DataExpMoy contenant la moyenne des expressions sur les réplicats de chaque gène, pour chaque traitement et chaque heure. DataExpMoy est donc une matrice de taille G × 18. Vous pourrez utiliser les variables ExpT1, ExpT2 et ExpT3 pour commenter vos résultats des questions suivantes.

## Analyse en composantes principales

```{r}
#Création du jeu de données DataExpMoy
dataR1<-data[,1:18]
dataR2<-data[,19:36]
dataACPg<-(dataR1+dataR2)/2
dim(dataACPg) #on a bien Gx18

#On ajoute les variables qualitatives
dataACPg<-cbind(dataACPg, ExpT1=data$ExpT1, ExpT2=data$ExpT2, ExpT3=data$ExpT3)
dim(dataACPg)
```
Expliquer avec les boxplots pourquoi on fait l'ACP centrée réduite
```{r,eval=T}
#ACP Centrée réduite
respcag<-PCA(dataACPg,quali.sup=c(19,20,21),scale.unit = TRUE,graph=F)
respcag$eig[1:5,]
fviz_eig(respcag)

```

```{r,eval=F}
fviz_pca_var(respcag) #graphique des corrélations entre les variables initiales et les méta-variables => Illisible

corrplot(respcag$var$cor,method="ellipse")  #les corrélations des variables initiales avec toutes les méta-variables => Plus lisible (même si c pas ouf)

fviz_pca_ind(respcag,col.ind="contrib",geom=c("point"))
```

## Clustering

## Kmeans

## Classification hiérarchique
