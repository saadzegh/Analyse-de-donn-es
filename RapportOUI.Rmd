---
title: "Rapport de projet - Analyse de données"
author: "ALIX Claire - ZEGHARI Saad"
institute : "INSA Toulouse"
date: "`r Sys.Date()`"
output: 
  pdf_document :
    toc : TRUE
    toc_depth : 2
    number_section : TRUE
geometry: margin=0.7in
header-includes:
   - \usepackage{dsfont}
   - \usepackage{color}
   - \newcommand{\1}{\mathds{1}}
---

```{r setup, include=FALSE }
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning=FALSE,fig.width=15,fig.height = 6, dpi=300)

#importation des packages utiles au projet
library(reticulate)
library(ggplot2)
library(corrplot)
library(FactoMineR)
library(factoextra)
library(gridExtra)
library(BioStatR)
library(reshape2)
library(forcats)
library(mclust)
library(cluster)
library(ppclust)
library(circlize)
library(ggalluvial)
library(clusterSim)
library(seriation)
library(knitr)

```
# Introduction

Dans ce projet, on s'intéresse à la population des gènes d'une plante modèle. On souhaite analyser un jeu de données représentant les différences d'expression d'un certain nombre de gènes pour plusieurs traitements appliqués et en tirer des conclusions pertinentes à propos l'expérience menée.

# Statistiques descriptives

## Description du jeu de données

```{r,eval=T, echo=FALSE}
#On récupère le jeu de données
data<-read.table("data.txt",header=T, sep=";", stringsAsFactors = T)
```

```{r,eval=T, echo=FALSE, results='hide'}
#commandes utiles pour l'analyse du jeu de données
head(data)
str(data)
names(data)
colnames(data)
attributes(data)
```
Le jeu de données fourni est composé d'un échantillon de 542 individus qui correspondent aux gènes de la plante modèle et comporte 39 variables statistiques qui caractérisent les individus. 

Grace à la commande `str(data)`, on observe que les 36 premières variables sont des variables quantitatives continues (variables nommées Tt_sh_Rr). Ces variables permettent d'évaluer les divergences d'expression des gènes pour trois traitements appliqués (T1, T2 et T3) par rapport à un état sans traitement de référence. Les données de chaque traitement ont été relevées durant 6 heures et ceci pour deux réplicats biologiques (R1 et R2).

Les trois dernières variables (nommées ExpT1, ExpT2 et ExpT3) sont des variables qualitatives nominales/ordinales dont les trois modalités sont : "Non", "Sous" et "Sur". Ces dernières représentent la décision si le gène est sur-exprimé, sous-exprimé ou non-exprimé à 6 heures par rapport à l'état de référence, pour chaque traitement.

Afin de visualiser les données, les premières lignes du jeu de données sont affichées dans la Table \ref{tab:tabdata}. 
En raison de la grande quantité de données, nous avons choisi de représenter seulement les variables T1_1h_R1 à T1_6h_R1 et ExpT1 qui donnent un aperçu de la structure du jeu de données pour le réplicat 1.

```{r, echo=FALSE, eval=TRUE}
kable(head(data[,c(1:6,37)]),caption="\\label{tab:tabdata}Les premières lignes du jeu de données.")
```

## Analyse uni-dimensionnelle

Nous commençons par faire quelques statistiques descriptives uni-dimensionnelles et bi-dimensionnelles afin de prendre en main le jeu de données.

### Variables qualitatives

Nous avons à notre disposition trois variables qualitatives : ExpT1, ExpT2, ExpT3, comme décrites précédemment. Pour extraire certaines tendances des traitements appliqués, nous analysons les fréquences d'apparition des différentes modalités et nous les représentons sous forme de diagramme en secteur dans la figure 1.

```{r echo=FALSE, eval=FALSE}
#Visualisation des modalités des trois variables qualitatives
levels(data$ExpT1)
levels(data$ExpT2)
levels(data$ExpT3)
```

```{r ,echo=F, eval=TRUE}
#Tableau des fréquences pour les variables qualitatives

Eff1<-table(data$ExpT1)
#df1<-data.frame(Eff1=c(Eff1),Freq=c(Eff1)/sum(Eff1))
#knitr::kable(t(df1))

Eff2<-table(data$ExpT2)
#df2<-data.frame(Eff2=c(Eff2),Freq=c(Eff2)/sum(Eff2))
#knitr::kable(t(df2))

Eff3<-table(data$ExpT3)
#df3<-data.frame(Eff3=c(Eff3),Freq=c(Eff3)/sum(Eff3))
#knitr::kable(t(df3))

#On regroupe les trois variables dans un même tableau pour pouvoir comparer les traitements
df<-data.frame(ExpT1=round(c(Eff1)*100/sum(Eff1),digits = 3), ExpT2=round(c(Eff2)*100/sum(Eff2),digits=3), ExpT3=round(c(Eff3)*100/sum(Eff3),digits=3))
knitr::kable(t(df),caption="\\label{tab:tabfreq}Tableau des fréquences pour les variables qualitatives (en %)")
```
COMMENT ZONE : Nous pouvons d'ores et déja observer des divergences de réaction entre les traitements 

- Différences de réaction entre les différents traitements
- Similarité des traitements 2 et 3 et traitement 1 à part
- traitement 1 sans réaction majeure/à majorité sans effet
- traitements 2 et 3 répartis de façon homogène entre sous et sur exprimé

```{r, echo=FALSE, eval=FALSE}
#barplots des effectifs des variables qualitatives (non utilisés dans le rapport)
g1 = ggplot(data) + geom_bar(aes(x = ExpT1)) 
g2 = ggplot(data) + geom_bar(aes(x = ExpT2)) 
g3 = ggplot(data) + geom_bar(aes(x = ExpT3)) 

grid.arrange(g1,g2,g3,ncol=3)
```

```{r, echo=TRUE, eval=FALSE, fig.align='center', fig.cap="Diagramme en secteur"}
#Reblochon des effectifs des variables qualitatives (non utilisés dans le rapport)

#GARDER LA LEGENDE, mettre le %ge sur le graphiqeu plus clair

# Pour ExpT1
df1 <- data.frame(group = levels(data$ExpT1), value = as.vector(table(data$ExpT1)) / nrow(data))
g1pie <- ggplot(df1, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7),  
            size = 5.5) +  # Taille du %age
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "bottom")+
  labs(fill = NULL)+    #Ne pas afficher "group" dans la légende
  ggtitle("ExpT1") # Ajouter le titre 

# Pour ExpT2
df2 <- data.frame(group = levels(data$ExpT2), value = as.vector(table(data$ExpT2)) / nrow(data))
g2pie <- ggplot(df2, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7), 
            size = 5.5) +
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "bottom")+
  labs(fill = NULL)+
  ggtitle("ExpT2") # Ajouter le titre

# Pour ExpT3
df3 <- data.frame(group = levels(data$ExpT3), value = as.vector(table(data$ExpT3)) / nrow(data))
g3pie <- ggplot(df3, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7), 
            size = 5.5) +
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "bottom")+
  labs(fill = NULL)+
  ggtitle("ExpT3") # Ajouter le titre

# Disposition des graphiques
grid.arrange(g1pie, g2pie, g3pie, ncol = 3)

```



### Variables Quantitatives

Nous analysons maintenant les variables quantitatives (Tt_sh_Rr)

Faire tous les codes qu'on utilisera pas dans le rapport (ex histogrammes, moyennes, variances...)



```{r, fig.align='center', fig.cap="boxplots"}
#On a regardé ça avec Tessa, pas sures de son utilité mais y'a moyen de trouver une interprétation logique avec les différences entre les différents boxplots

plot1<-ggplot(data,aes(x=ExpT1,y=T1_6H_R1 ))+geom_boxplot()
plot2<-ggplot(data,aes(x=ExpT2,y=T2_6H_R1))+geom_boxplot()
plot3<-ggplot(data,aes(x=ExpT3,y=T3_6H_R1 ))+geom_boxplot()
plot4<-ggplot(data,aes(x=ExpT1,y=T1_6H_R2 ))+geom_boxplot()
plot5<-ggplot(data,aes(x=ExpT2,y=T2_6H_R2))+geom_boxplot()
plot6<-ggplot(data,aes(x=ExpT3,y=T3_6H_R2 ))+geom_boxplot()
grid.arrange(plot1,plot2,plot3,plot4,plot5,plot6,ncol=6)
```

```{r,echo=F, fig.cap="Boxplot du réplicat R1"}
#mettre les deux boxplots sur deux graphes différents pour que ce soit plus lisible
data1 <- melt(data[, -c(19:39)])
ggplot(data1, aes(x = variable, y = value)) + geom_boxplot()
```

```{r,echo=F, fig.cap="Boxplot du réplicat R2"}
data2 <- melt(data[, -c(1:18,37:39)])
ggplot(data2, aes(x = variable, y = value)) + geom_boxplot()
```

```{r ,echo=F,fig.cap="matrice des corrélations"}
corrplot(cor(data[, -c(37:39)]), method = "ellipse")
```

```{r,eval=F}
dataScale<-scale(data[,-c(37:39)], center = TRUE , scale = FALSE)
round(apply(dataScale,2,mean))

#Pas nécéssaire
```

# ACP CENTRéE

```{r,eval=F}

respca<-PCA(t(data[c(1:36)]),scale.unit = F,graph=F)
respca$eig
fviz_eig(respca)

```

```{r,eval=F}
plot(respca,choix="varcor") 
#fviz_pca_var(respca) #graphique des corrélations entre les variables initiales et les méta-variables => Illisible

corrplot(respca$var$cor,method="ellipse")  #les corrélations des variables initiales avec toutes les méta-variables => Plus lisible (même si c pas ouf)

fviz_pca_ind(respca,col.ind="contrib",geom=c("point"))
fviz_pca_ind(respca,geom=c("point"),select.ind = list(cos2=0.95))


#ATTENTION : problème d'overflow, à regler
```

# ACP centrée réduite


```{r,eval=F}

respca2<-PCA(data[c(1:36)],scale.unit = TRUE,graph=F)
respca2$eig
fviz_eig(respca2)

```

```{r,eval=F}
#plot(respca2,choix="varcor") 
fviz_pca_var(respca2) #graphique des corrélations entre les variables initiales et les méta-variables => Illisible

corrplot(respca2$var$cor,method="ellipse")  #les corrélations des variables initiales avec toutes les méta-variables => Plus lisible (même si c pas ouf)

fviz_pca_ind(respca2,col.ind="contrib",geom=c("point"))
fviz_pca_ind(respca2,geom=c("point"),select.ind = list(cos2=0.95))
```
# TENTATIVE DE KmEANS
```{r,eval=F}
reskmeans<-kmeans(dataScale,4) 
fviz_pca_ind(respca,habillage=as.factor(reskmeans$cluster) ,geom=c("point"))
```
```{r,eval=F}
fviz_cluster(reskmeans,data=dataScale,
             ellipse.type="norm",labelsize=8,
             geom=c("point"))+ggtitle("")
fviz_pca_ind(respca,col.ind=as.factor(reskmeans$cluster),
             geom = c("point"),axes=c(1,2))
```
# Méthode PAM (approximative)
```{r,eval=F}

Kmax<-15
resPAMcl<-matrix(0,nrow=nrow(data),ncol=Kmax-1)
Silhou<-NULL
for (k in 2:Kmax){
  resaux<-pam(dataScale,k, metric="euclidean")
  resPAMcl[,k-1]<-resaux$clustering
  aux<-silhouette(resPAMcl[,k-1], daisy(dataScale))
  Silhou<-c(Silhou,mean(aux[,3]))
}

df<-data.frame(K=2:Kmax,Silhouette=Silhou)
ggplot(df,aes(x=K,y=Silhouette))+
  geom_point()+
  geom_line()+theme(legend.position = "bottom")

#on a le coude à 4, on prend 4 classes du coup


#Les lignes suivantes font un truc mais g pas encore trop compris
# aux<-silhouette(resPAMcl[,1], daisy(dataScale))
# fviz_silhouette(aux)+theme(plot.title = element_text(size =9))
# 
# adjustedRandIndex(resPAMcl[,1],reskmeanscl[,3])
# table(resPAMcl[,1],reskmeanscl[,3])

```
On a le coude 4, donc on va choisir 4 classes
