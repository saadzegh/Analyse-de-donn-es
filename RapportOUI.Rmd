---
title: "Rapport de projet - Analyse de données"
author: "ALIX Claire - ZEGHARI Saad"
institute : "INSA Toulouse"
date: "`r Sys.Date()`"
output: 
  pdf_document :
    toc : TRUE
    toc_depth : 3
    number_section : TRUE
geometry: margin=0.7in
header-includes:
   - \usepackage{dsfont}
   - \usepackage{color}
   - \newcommand{\1}{\mathds{1}}
---

```{r setup, include=FALSE }
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning=FALSE,fig.align="center",fig.width=15,fig.height = 6, dpi=300)

#importation des packages utiles au projet
library(reticulate)
library(ggplot2)
library(corrplot)
library(FactoMineR)
library(factoextra)
library(gridExtra)
library(BioStatR)
library(reshape2)
library(forcats)
library(mclust)
library(cluster)
library(ppclust)
library(circlize)
library(ggalluvial)
library(clusterSim)
library(seriation)
library(knitr)

```
# Introduction

Dans ce projet, on s'intéresse à la population des gènes d'une plante modèle. On souhaite analyser un jeu de données représentant les différences d'expression d'un certain nombre de gènes pour plusieurs traitements appliqués et en tirer des conclusions pertinentes à propos l'expérience biologique menée.

Tout au long de ce rapport, le symbole {\textbf{\textsf{R}}} indique que des informations dans le code ne sont pas transmises dans le rapport.

# Statistiques descriptives

## Description du jeu de données

```{r,eval=T, echo=FALSE}
#On récupère le jeu de données
data<-read.table("DataProjet3MIC-2425.txt",header=T, sep=";", stringsAsFactors = T)
```
Afin de décrire l'ensemble du jeu de données, nous avons utilisé quelques commandes {\textbf{\textsf{R}}}.
```{r,eval=T, echo=FALSE, results='hide'}
#commandes utiles pour l'analyse du jeu de données
head(data)
str(data)
names(data)
colnames(data)
attributes(data)
```
Le jeu de données fourni est composé d'un échantillon de 542 individus qui correspondent aux gènes de la plante modèle et comporte 39 variables statistiques qui caractérisent les individus. 

Grace à la commande `str(data)`, on observe que les 36 premières variables sont des variables quantitatives continues (variables nommées Tt_sh_Rr). Ces variables permettent d'évaluer les divergences d'expression des gènes pour trois traitements appliqués (T1, T2 et T3) par rapport à un état sans traitement de référence. Les données de chaque traitement ont été relevées durant 6 heures et ceci pour deux réplicats biologiques (R1 et R2).

Les trois dernières variables (nommées ExpT1, ExpT2 et ExpT3) sont des variables qualitatives nominales dont les trois modalités sont : "Non", "Sous" et "Sur". Ces dernières représentent la décision si le gène est sur-exprimé, sous-exprimé ou non-exprimé à 6 heures par rapport à l'état de référence, pour chaque traitement.

Afin de visualiser les données, les premières lignes du jeu de données sont affichées dans la Table \ref{tab:tabdata}. 
En raison de la grande quantité de données, nous avons choisi de représenter seulement les variables T1_1h_R1 à T1_6h_R1 et ExpT1 qui donnent un aperçu de la structure du jeu de données pour le réplicat R1.

```{r, echo=FALSE, eval=TRUE}
kable(head(data[,c(1:6,37)]),caption="\\label{tab:tabdata}Les premières lignes du jeu de données.")
```

## Analyse uni-dimensionnelle

Nous commençons par faire quelques statistiques descriptives uni-dimensionnelles afin de prendre en main le jeu de données.

### Variables qualitatives

```{r echo=FALSE, eval=FALSE}
#Visualisation des modalités des trois variables qualitatives
levels(data$ExpT1)
levels(data$ExpT2)
levels(data$ExpT3)
```

Nous avons à notre disposition trois variables qualitatives : ExpT1, ExpT2, ExpT3 comme décrites précédemment {\textbf{\textsf{R}}}. Pour extraire certaines tendances des traitements appliqués, nous analysons les fréquences d'apparition des différentes modalités et nous les représentons sous forme de diagrammes en secteurs dans la Figure \ref{fig:diagsecteurs}.

```{r ,echo=F, eval=FALSE}
#Tableau des fréquences pour les variables qualitatives (non utilisé dans le rapport)

Eff1<-table(data$ExpT1)
#df1<-data.frame(Eff1=c(Eff1),Freq=c(Eff1)/sum(Eff1))
#knitr::kable(t(df1))

Eff2<-table(data$ExpT2)
#df2<-data.frame(Eff2=c(Eff2),Freq=c(Eff2)/sum(Eff2))
#knitr::kable(t(df2))

Eff3<-table(data$ExpT3)
#df3<-data.frame(Eff3=c(Eff3),Freq=c(Eff3)/sum(Eff3))
#knitr::kable(t(df3))

#On regroupe les trois variables dans un même tableau pour pouvoir comparer les traitements
df<-data.frame(ExpT1=round(c(Eff1)*100/sum(Eff1),digits = 3), ExpT2=round(c(Eff2)*100/sum(Eff2),digits=3), ExpT3=round(c(Eff3)*100/sum(Eff3),digits=3))
knitr::kable(t(df),caption="\\label{tab:tabfreq}Tableau des fréquences pour les variables qualitatives (en %)")
```

```{r, echo=FALSE, eval=FALSE}
#barplots des effectifs des variables qualitatives (non utilisé dans le rapport)
g1 = ggplot(data) + geom_bar(aes(x = ExpT1)) 
g2 = ggplot(data) + geom_bar(aes(x = ExpT2)) 
g3 = ggplot(data) + geom_bar(aes(x = ExpT3)) 
grid.arrange(g1,g2,g3,ncol=3)
```

```{r, echo=FALSE, eval=TRUE, fig.align='center', fig.cap="\\label{fig:diagsecteurs}Diagrammes en secteurs des fréquences des variables ExpT1, ExpT2 et ExpT3"}
#Diagrammes en secteurs des fréquences pour les variables qualitatives

#Pour ExpT1
df1 <- data.frame(group = levels(data$ExpT1), value = as.vector(table(data$ExpT1)) / nrow(data))
g1pie <- ggplot(df1, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7),  
            size = 6, family = "serif", fontface = "bold") +  #Changer la police
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_line(color = "gray"),  #Lignes de la grille visibles
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, family = "serif", size = 20, face = "bold")  #Centrer et styliser le titre
  ) +
  labs(fill = NULL) +
  ggtitle("ExpT1") 

#Pour ExpT2
df2 <- data.frame(group = levels(data$ExpT2), value = as.vector(table(data$ExpT2)) / nrow(data))
g2pie <- ggplot(df2, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7), 
            size = 6, family = "serif", fontface = "bold") +  #Changer la police
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_line(color = "gray"),  #Lignes de la grille visibles
    axis.text.y = element_text(size = 10),       #Indicateurs autour du graphique
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, family = "serif", size = 20, face = "bold")  #Centrer et styliser le titre
  ) +
  labs(fill = NULL) +
  ggtitle("ExpT2") 

#Pour ExpT3
df3 <- data.frame(group = levels(data$ExpT3), value = as.vector(table(data$ExpT3)) / nrow(data))
g3pie <- ggplot(df3, aes(x = "", y = value, fill = group)) + 
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  geom_text(aes(label = scales::percent(value, accuracy = 0.1)), 
            position = position_stack(vjust = 0.7), 
            size = 6, family = "serif", fontface = "bold") +  # Changer la police
  theme_grey(base_size = 15) + 
  theme(
    panel.grid = element_line(color = "gray"),  #Lignes de la grille visibles
    axis.text.y = element_text(size = 10),
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, family = "serif", size = 20, face = "bold")  #Centrer et styliser le titre
  ) +
  labs(fill = NULL) +
  ggtitle("ExpT3") 

#Disposition des graphiques
grid.arrange(g1pie, g2pie, g3pie, ncol = 3)

```
D'après la Figure \ref{fig:diagsecteurs}, on peut déjà remarquer que les traitements diffèrent dans la réaction des gènes. En effet, on observe une grande similarité entre les traitements T2 et T3 avec des réactions réparties de façon quasi-homogène entre les modalités "sous" et "sur" exprimé. Pour sa part, le traitement T1 n'a aucun effet sur la majorité des gènes, qui n'expriment pas de différence particulière par rapport à l'état de référence (81% de "non" exprimé pour ExpT1).


### Variables quantitatives

Nous analysons maintenant les variables quantitatives de notre jeu de données (variables Tt_sh_Rr) individuellement. 

Pour apréhender les différences entre les variables quantitatives et en raison du grand nombre de variables à analyser, nous avons décidé de tracer leurs boxplots respectifs, regroupés par variables d'un même réplicat dans la Figure \ref{fig:boxplots_quantitatives1} et la Figure \ref{fig:boxplots_quantitatives2}. Ceci nous permet de résumer les variables de manière simple et visuelle, d'identifier les valeurs extrêmes, de comprendre la répartition des observations et de comparer les deux réplicats ensemble ainsi que les traitements et les heures d'observation. {\textbf{\textsf{R}}}

```{r,echo=F, fig.align="center", fig.width=15, fig.height = 5, fig.cap="\\label{fig:boxplots_quantitatives1}Boxplots des variables quantitatives du réplicat R1"}
#On sépare les boxplots des deux réplicats pour avoir des graphiques plus lisibles et comparables
data1 <- melt(data[, -c(19:39)])
ggplot(data1, aes(x = variable, y = value)) + geom_boxplot()
```

```{r,echo=F, fig.align="center", fig.width=15, fig.height = 5, fig.cap="\\label{fig:boxplots_quantitatives2}Boxplots des variables quantitatives du réplicat R2"}
data2 <- melt(data[, -c(1:18,37:39)])
ggplot(data2, aes(x = variable, y = value)) + geom_boxplot()
```
Lorsque l'on compare les boxplots obtenus sur les Figures \ref{fig:boxplots_quantitatives1} et \ref{fig:boxplots_quantitatives2}, on peut observer de grandes similitudes entre les résultats obtenus pour le réplicat R1 et ceux du réplicat R2, ce qui prouve une certaine cohérence de l'expérience menée.

Nous pouvons par ailleurs comparer les médianes et les écarts interquartiles respectifs des variables pour évaluer la dispersion du jeu de données. On observe alors que les séries statistiques sont très variables. En effet, bien qu'elles soient basées sur des échelles similaires, les variances des variables correspondant aux traitements T2 et T3 sont plus grandes que les variances des variables du traitement T1.

Autre interprétation

```{r, echo=FALSE, eval=FALSE}
#On compare les indicateurs numériques (variances, médianes, moyennes) pour les variables quantitatives

# Calculer les variances pour chaque colonne (variables 1 à 36)
variances <- apply(data[, 1:36], 2, var)

# Créer un data frame pour ggplot
variance_data <- data.frame(
  variable = names(variances), # Noms des colonnes
  variance = variances         # Variances calculées
)

# Créer le graphique
library(ggplot2)
ggplot(variance_data, aes(x = variable, y = variance)) +
  geom_point(size = 2, color = "purple") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(
    title = "Graphique des variances par variable",
    x = "Variable",
    y = "Variance"
  )

#Mettre le logo R
```

```{r, echo=FALSE, eval=FALSE}
# Calculer les médianes pour chaque colonne (variables 1 à 36)
medians <- apply(data[, 1:36], 2, median)

# Créer un data frame pour ggplot
median_data <- data.frame(
  variable = names(medians), # Noms des colonnes
  median = medians           # Médianes calculées
)

# Créer le graphique
library(ggplot2)
ggplot(median_data, aes(x = variable, y = median)) +
  geom_point(size = 2, color = "blue") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(
    title = "Graphique des médianes par variable",
    x = "Variable",
    y = "Médiane"
  )
```
```{r, echo=FALSE, eval=FALSE}
# Calculer les moyennes pour chaque colonne (variables 1 à 36)
means <- colMeans(data[, 1:36])

# Créer un data frame pour ggplot
mean_data <- data.frame(
  variable = names(means), # Noms des colonnes
  mean = means             # Moyennes calculées
)

# Créer le graphique
library(ggplot2)
ggplot(mean_data, aes(x = variable, y = mean)) +
  geom_point(size = 2, color = "red") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(
    title = "Graphique des moyennes par variable",
    x = "Variable",
    y = "Moyenne"
  )
```


## Analyse bi-dimensionnelle

Nous nous intéressons maintenant à l'analyse bi-dimensionnelle de toutes les variables du jeu de données.

### Deux variables quantitatives

Nous commençons par analyser les variables quantitatives entre elles. Afin d'analyser les liaisons entre ces variables, nous affichons en Figure \ref{fig:matricecorrelations} la matrice des corrélations qui représente les coefficients de corrélations des variables deux à deux. La corrélation mesure la dépendance linéaire entre deux variables

```{r ,echo=F,fig.align = "center", fig.width=20, fig.height = 10, fig.cap="\\label{fig:matricecorrelations}Matrice des corrélations des variables quantitatives"}
corrplot(cor(data[, -c(37:39)]), method = "ellipse")
```
D'après la Figure \ref{fig:matricecorrelations}, on observe des corrélations fortes entre les variables des traitement T2 et T3 tandis que les variables du traitement T1 sont globalement peu corrélées aux autres variables.

### Deux variables qualitatives

Dans le cas de deux variables qualitatives, on représente les profils-ligne ou profils-colonne dans la Figure \ref{fig:profil_ligne}.

1. Tableau de contingence
2. Mosaic plot 
3. Indice de liaison 

```{r, fig.height=5, fig.width=15, fig.cap="\\label{fig:profil_ligne}Profils ligne des variables qualitatives"}
#prop.table(table(data$ExpT1,data$ExpT2),margin=1)
g1<-ggplot(data,aes(x=ExpT1,fill=ExpT2))+
geom_bar(position = "fill")

#prop.table(table(data$ExpT1,data$ExpT3),margin=1)
g2<-ggplot(data,aes(x=ExpT1,fill=ExpT3))+
geom_bar(position = "fill")

#prop.table(table(data$ExpT2,data$ExpT3),margin=1)
g3<-ggplot(data,aes(x=ExpT2,fill=ExpT3))+
geom_bar(position = "fill")

grid.arrange(g1,g2,g3,ncol=3)

#mosaicplot(table(data$ExpT1,data$ExpT2)) #illisible
#mosaicplot(table(data$ExpT1,data$ExpT3))
```
Analyse des profils lignes-colonne

### Une variable qualitative et une variable quantitative

Enfin, nous nous intéressons à l'analyse du degré de liaison de certaines variables quantitatives avec des variables qualitatives. Figure \ref{fig:boxplots_paralleles}
On trace la distribution de la variable quantitative 𝑌 en fonction de
chaque modalité de la variable qualitative 𝑋
1. Représentation graphique : boxplots parallèles
Plus les boxplot sont “diférents”, plus X et Y sont liés
ATTENTION 1 VARIABLE QUALITATIVE ET 1 VARIABLE QUANTITATIVE SONT LIES PAS CORRELEE !!!!!!!
2. Carré du rapport de corrélation empirique 
si proche de 0 X et Y ne sont pas liées 
si proche de 1 X et Y sont liées 

```{r, fig.align='center', fig.cap="\\label{fig:boxplots_paralleles}Boxplots parallèles"}

plot1<-ggplot(data,aes(x=ExpT1,y=T1_6H_R1 ))+geom_boxplot()
plot2<-ggplot(data,aes(x=ExpT2,y=T2_6H_R1))+geom_boxplot()
plot3<-ggplot(data,aes(x=ExpT3,y=T3_6H_R1 ))+geom_boxplot()
plot4<-ggplot(data,aes(x=ExpT1,y=T1_6H_R2 ))+geom_boxplot()
plot5<-ggplot(data,aes(x=ExpT2,y=T2_6H_R2))+geom_boxplot()
plot6<-ggplot(data,aes(x=ExpT3,y=T3_6H_R2 ))+geom_boxplot()
grid.arrange(plot1,plot2,plot3,plot4,plot5,plot6,ncol=6)
```

# Analyse des Tt_sh_Rr

## Analyse en composantes principales

Menez une analyse en composantes principales où les Tt_sH_Rr sont les individus d´ecrits par les
gènes.
Pour savoir si utilise l'ACP centrée ou l'ACP centrée reduite, on compare les pourcentages des variances cumulées sur les deux ACP. Car on ne peut pas utiliser des boxplots pour le déterminer (trop de variables)

```{r,echo=FALSE, eval=T}
dataACPv<-t(data[c(1:36)]) #on retire les variables qualitatives et on transpose le dataframe 
dim(dataACPv) #on vérifie les bonnes dimensions du jeu de données

#ACP centrée
resacpa<-PCA((dataACPv),scale.unit = F,graph=F)
resacpa$eig[1:3,]
```
Au vu du nombre de variables très élevé, on ne peut pas s'assurer que l'odre de grandeur des variances est similaire? On fait donc une ACP centrée réduite.
```{r, echo=FALSE, eval=TRUE}
#ACP centrée réduite
respcav<-PCA((dataACPv),scale.unit = T,graph=F)
respcav$eig[1:3,]
fviz_eig(respcav)
```
Les deux premières composantes principales (Dim1 et Dim2) capturent 71,1 % et 10,5 % de la variance totale, soit un tota cumulé de 81,6%. Cela signifie que l’essentiel de l’information contenue dans les données peut être visualisé dans un espace bidimensionnel.

AAAAAAAAAAAAAAAAA qui va permettre de récupérer plus d'information que l'ACP centréé (variances cumulées à 81,6% contre 80,5%) AAAAAAAAAAAAAAAAAAAAA

```{r,eval=T}
#graphe des variables
fviz_pca_var(respcav) #graphique des corrélations entre les variables initiales et les méta-variables => Illisible

#graphe des individus
fviz_pca_ind(respcav,col.ind="contrib",geom=c("point"))

```
Graphe variable => Illisible (rien conclure quant aux variables car bcp trop nombreuses)
=> On fait une analyse séparée (voit graphe du dessous)

Graphe individu => Pas un regroupement spécifique, on a 2/3. On a une variabilité des réaction en fonction des spécifités des individus.


PARLER DE L'INERTIE
```{r}
# Habillage sur le graphe des individus - Réplicats
colors <- rep("red", nrow(dataACPv))
colors[1:18] <- "blue"
fviz_pca_ind(respcav, mean.point=FALSE, geom = "point", col.ind = colors) +
  scale_color_manual(values = c("blue" = "blue", "red" = "red"), 
                     labels = c("R1", "R2")) +
  labs(color = "Réplicats")
```
Les individus issus des réplicats R1 et R2 sont distribués de manière équilibrée le long des deux dimensions. la variabilité n'est pas entièrement due aux différents réplicas. 
On peut en conclure que les facteurs des traitements et des heures contribuent de manière significative à la structure des données.

```{r}
# Habillage sur le graphe des individus - Traitements
colors <- rep("red", nrow(dataACPv))
colors[c(1:6,19:25)] <- "blue"
colors[c(7:12,26:32)] <- "green"
fviz_pca_ind(respcav, mean.point=FALSE, geom = "point", col.ind = colors) +
  scale_color_manual(values = c("blue" = "blue", "green" = "green", "red" = "red"), 
                     labels = c("T1", "T2", "T3")) +
  labs(color = "Traitements")
```
Les observations associées au traitement T1 se situent principalement sur la gauche du graphique, tandis que celles des traitements T2 et T3 sont davantage mélangées à droite.

Cela reflète une différenciation claire entre les effets du traitement T1 et ceux des traitements T2 et T3, ce qui appuie l'observation déjà faite lors de l'analyse bi-dimensionnelle.

```{r}
# Habillage sur le graphe des individus - Heures
colors <- rep("red", nrow(dataACPv))
colors[c(1,7,13,19,25,31)] <- "blue"    # Heure 1
colors[c(2,8,14,20,26,32)] <- "green"   # Heure 2
colors[c(3,9,15,21,27,33)] <- "purple"  # Heure 3
colors[c(4,10,16,22,28,34)] <- "yellow" # Heure 4
colors[c(5,11,17,23,29,35)] <- "orange" # Heure 5

fviz_pca_ind(respcav, mean.point=FALSE, geom = "point", col.ind = colors) +
  scale_color_manual(values = c("blue" = "blue", "green" = "green", "purple" = "purple", 
                                "yellow" = "yellow", "orange" = "orange", "red" = "red"),
                     labels = c("Heure 1", "Heure 2", "Heure 3", "Heure 4", "Heure 5", "Heure 6")) +
  labs(color = "Heures")
```
A l’heure 1, toutes les observations, quel que soit le traitement, se regroupent sur la gauche du graphique. On a une faible contribution de la dim1 et une dynamique plus heterogène sur la contribution de la composante dim2. 

Au bout de 2h, on observe que la séparation se fait au bout de la deuxième heure.
La contribution par rapport à dim1 est opposée entre le premier traitement les 2 autres traitements.

Après cette séparation, la variabilité des dimensions oscille principalement à la contribution de dim2 entre chaque heure.


## Clustering

### Détermination du nombre de classes


```{r}
#Inertie intraclasse

Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(dataACPv),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
  resaux<-kmeans(dataACPv,k)
  reskmeanscl[,k-1]<-resaux$cluster
  Iintra<-c(Iintra,resaux$tot.withinss)
}

df<-data.frame(K=2:15,Iintra=Iintra)
g1<-ggplot(df,aes(x=K,y=Iintra))+
  geom_line()+
  geom_point()+
  xlab("Nombre de classes")+
  ylab("Inertie intraclasse") 
  #ggtitle("Figure 9.1: Inertie intraclasse")
```


```{r}
#silhouette

Silhou<-NULL
for (k in 2:Kmax){
   aux<-silhouette(reskmeanscl[,k-1], daisy(dataACPv))
   Silhou<-c(Silhou,mean(aux[,3]))
}

df<-data.frame(K=2:Kmax,Silhouette=Silhou)
g2<-ggplot(df,aes(x=K,y=Silhouette))+
  geom_point()+
  geom_line()+theme(legend.position = "bottom")
# ggtitle("Figure 10 : Coefficients silhouette")

aux<-silhouette(reskmeanscl[,3],daisy(dataACPv))
g3<-fviz_silhouette(aux)+
  theme(plot.title = element_text(size =9)) 
#+ ggtitle("Figure 11 : Visualisation des silhouettes")
rm(df,Silhou,aux)

g1 <- g1 + ggtitle("Figure 9.1: Inertie intraclasse") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))
g2 <- g2 + ggtitle("Figure 9.2: Coefficients silhouettes") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))
g3 <- g3 + ggtitle("Figure 9.3 : Visualisation des silhouettes") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))

grid.arrange(g1,g2,g3,ncol=3)
```

Blablabla on choisi 3/4 classes parce que...

### Kmeans

```{r,echo=F,eval=T}
reskmeans<-kmeans(dataACPv,3) 
```


```{r,eval=F}
fviz_cluster(reskmeans,data=dataACPv,
             ellipse.type="norm",labelsize=8,
             geom=c("point"))+ggtitle("")

fviz_pca_ind(respcav,col.ind=as.factor(reskmeans$cluster),
             geom = c("point"),axes=c(1,2))
```
Interprétation Kmeans

Il faut regarder ce qu'il y a dans reskmeans$cluster pour voir qu'elle variable va dans quelle classe et commenter 

On ne compare pas avec les variables qualitatives car il n'y en a pas 

### Classification hiérarchique

```{r}
# dendogramme
dist_dataACPv = dist(dataACPv)

hward<-hclust(dist_dataACPv, method = "ward.D2") 
fviz_dend(hward,show_labels=FALSE)
```
```{r ,fig.cap="A compléter v"}
# A COMPLETER
CH<-NULL
Kmax<-20
for (k in 2:Kmax){
  CH<-c(CH,index.G1(dataACPv, cl= cutree(hward,k)))
}
#On prend k = 3
daux<-data.frame(NbClust=2:Kmax,CH=CH)
g1<-ggplot(daux,aes(x=NbClust,y=CH))+
  geom_line()+
  geom_point()

ClustCH<-cutree(hward,k=3)
g2<-fviz_dend(hward, show_labels = FALSE, k = 3)
g3<-fviz_pca_ind(respcav, geom = c("point"), habillage = as.factor(ClustCH)) 

grid.arrange(g1,g2,g3,ncol=3)
```

# Analyse des gènes

Construisez un jeu de données DataExpMoy contenant la moyenne des expressions sur les réplicats de chaque gène, pour chaque traitement et chaque heure. DataExpMoy est donc une matrice de taille G × 18. Vous pourrez utiliser les variables ExpT1, ExpT2 et ExpT3 pour commenter vos résultats des questions suivantes.

## Analyse en composantes principales

```{r}
#Création du jeu de données DataExpMoy
dataR1<-data[,1:18]
dataR2<-data[,19:36]
dataACPg<-(dataR1+dataR2)/2
dim(dataACPg) #on a bien Gx18

#On ajoute les variables qualitatives
dataACPg<-cbind(dataACPg, ExpT1=data$ExpT1, ExpT2=data$ExpT2, ExpT3=data$ExpT3)
dim(dataACPg)
```
On fait une ACP centrée réduite car on a des variances de différentes échelles. Voir outlier figure X.

```{r,eval=T}
#ACP Centrée réduite
respcag<-PCA(dataACPg,quali.sup=c(19,20,21),scale.unit = TRUE,graph=F)
respcag$eig[1:5,]
fviz_eig(respcag)

```
Les deux premières composantes principales (Dim1 et Dim2) capturent 59,2 % et 22,2 % de la variance totale, soit un total cumulé de 81,4%. Cela signifie que l’essentiel de l’information contenue dans les données peut être visualisé dans un espace bidimensionnel.

```{r,eval=F}
fviz_pca_var(respcag) #graphique des corrélations entre les variables initiales et les méta-variables => Illisible

corrplot(respcag$var$cor,method="ellipse")  #les corrélations des variables initiales avec toutes les méta-variables => Plus lisible (même si c pas ouf)

fviz_pca_ind(respcag,col.ind="contrib",geom=c("point"))
```
Cercle des correlations:
Les variables liées aux traitements T2 et T3 sont fortement corrélées et influencées par Dim2, tandis que celles de T1 sont davantage associées à Dim1. On note une exception pour les gènes associé à l’expérience T3_1H_R1, qui semble influencé à la fois par Dim1 et Dim2.

Graph des individus:
Les points sont en majorités éloignés de l’origine. La majorité des gènes présentent donc des variations marquées.
Ceux qui sont proches de l'origine, montrent une variation faible, ce qui peut correspondre aux gènes du traitement 1.

Gènes qui influencent dim1 contribue majoritairement de façon uniforme à dim2 (faiblement)
Pour les gènes avec une faible contribution de dim1, plus de répartition sur la contribution de dim2

## Clustering

```{r}
dataACPgC<-scale(dataACPg[,-c(19,20,21)] ,center=TRUE,scale=TRUE)

Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(dataACPg),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
  resaux<-kmeans(dataACPgC,k)
  reskmeanscl[,k-1]<-resaux$cluster
  Iintra<-c(Iintra,resaux$tot.withinss)
}

df<-data.frame(K=2:15,Iintra=Iintra)
g1<-ggplot(df,aes(x=K,y=Iintra))+
  geom_line()+
  geom_point()+
  xlab("Nombre de classes")+
  ylab("Inertie intraclasse")

```

```{r}
# Silhouette 

Silhou<-NULL
for (k in 2:Kmax){
   aux<-silhouette(reskmeanscl[,k-1], daisy(dataACPgC))
   Silhou<-c(Silhou,mean(aux[,3]))
}

df<-data.frame(K=2:Kmax,Silhouette=Silhou)
g2<-ggplot(df,aes(x=K,y=Silhouette))+
  geom_point()+
  geom_line()+theme(legend.position = "bottom")

aux<-silhouette(reskmeanscl[,3],daisy(dataACPgC))
g3<-fviz_silhouette(aux)+
  theme(plot.title = element_text(size =9))
rm(df,Silhou,aux)


grid.arrange(g1,g2,g3,ncol=3)
```

### Kmeans

```{r,echo=F,eval=T}
reskmeans<-kmeans(dataACPgC,3) 
```


```{r,eval=F}
fviz_cluster(reskmeans,data=dataACPgC,
             ellipse.type="norm",labelsize=8,
             geom=c("point"))+ggtitle("")

fviz_pca_ind(respcag,col.ind=as.factor(reskmeans$cluster),
             geom = c("point"),axes=c(1,2))
```




### Classification hiérarchique

```{r}
# dendogramme
dist_dataACPg = dist(dataACPgC)

hward<-hclust(dist_dataACPg, method = "ward.D2") 
fviz_dend(hward,show_labels=FALSE)
```


```{r}
# A COMPLETER
CH<-NULL
Kmax<-20
for (k in 2:Kmax){
  CH<-c(CH,index.G1(dataACPgC, cl= cutree(hward,k)))
}
#On prend k = 3
daux<-data.frame(NbClust=2:Kmax,CH=CH)
g1<-ggplot(daux,aes(x=NbClust,y=CH))+
  geom_line()+
  geom_point()

ClustCH<-cutree(hward,k=3)
g2<-fviz_dend(hward, show_labels = FALSE, k = 3)
g3<-fviz_pca_ind(respcag, geom = c("point"), habillage = as.factor(ClustCH)) 

grid.arrange(g1,g2,g3,ncol=3)
```

```{r}
clust1<-paste("Cl-K",reskmeans$cluster,sep="")
clust2<-paste("Cl-hiérarchique",ClustCH,sep="")
Tab<-melt(table(clust1,clust2))
ggplot(Tab,aes(y=value,axis1=clust1,axis2=clust2))+
  geom_alluvium(aes(fill=clust1))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure 15.2")
  theme(legend.position = "none")
```

## Clustering 2 (comparaison avec variable qualitatives) 

```{r}
A<-pam(data[37:39], 3, metric = "euclidean")
A$medoids
adjustedRandIndex(A$clustering,data$ExpT1,data$ExpT2,data$ExpT3)
table(data$ExpT1,data$ExpT2,data$ExpT3,A$clustering)
```


### Partie de comparaison

```{r}
g1<-fviz_pca_ind(respcag,habillage="ExpT1",geom=c("point"))
g2<-fviz_pca_ind(respcag,habillage="ExpT2",geom=c("point"))
g3<-fviz_pca_ind(respcag,habillage="ExpT3",geom=c("point"))
grid.arrange(g1,g2,g3,ncol=3)

```

```{r}
clust<-paste("Cl-K",reskmeans$cluster,sep="")
Tab<-melt(table(clust,dataACPg[,19]))
g1<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("Figure 15.3")+
  theme(legend.position = "none")
```


```{r}
clust<-paste("Cl-K",reskmeans$cluster,sep="")
Tab<-melt(table(clust,dataACPg[,20]))
g2<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure15.1 a completer")
  theme(legend.position = "none")

```

```{r}
clust<-paste("Cl-K",reskmeans$cluster,sep="")
Tab<-melt(table(clust,dataACPg[,21]))
g3<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure 15.2")
  theme(legend.position = "none")
grid.arrange(g1,g2,g3,ncol=3)

```
```{r}
clust<-paste("Cl-hiérarchique",ClustCH,sep="")
Tab<-melt(table(clust,dataACPg[,19]))
g1<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("Figure 15.3")+
  theme(legend.position = "none")
```


```{r}
clust<-paste("Cl-hiérarchique",ClustCH,sep="")
Tab<-melt(table(clust,dataACPg[,20]))
g2<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure15.1 a completer")
  theme(legend.position = "none")

```

```{r}
clust<-paste("Cl-hiérarchique",ClustCH,sep="")
Tab<-melt(table(clust,dataACPg[,21]))
g3<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure 15.2")
  theme(legend.position = "none")
grid.arrange(g1,g2,g3,ncol=3)

```
