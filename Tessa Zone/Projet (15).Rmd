---
title: "Projet Analyse de données"
author: "Despaux Laurine/ Ledroit Tessa"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
    toc_depth: 2
    number_section: yes
  word_document:
    toc: yes
    toc_depth: '2'
institute: INSA Toulouse
geometry: margin=0.5in
header-includes:
- \usepackage{dsfont}
- \usepackage{color}
- \newcommand{\1}{\mathds{1}}
- \usepackage{amsmath, amssymb}
---

```{r setup,include=FALSE}
knitr::opts_chunk$set(echo=FALSE,message = FALSE, warning = FALSE,fig.width=15, fig.height=6, dpi=300)

library(reticulate)
library(ggplot2)
library(corrplot)
library(FactoMineR)
library(factoextra)
library(gridExtra)
library(BioStatR)
library(forcats)
library(reshape2)
library(mclust) 
library(cluster)
library(ppclust)
library(circlize)
library(ggalluvial)
library(clusterSim)
library(dbscan)
library(seriation)
library(grid)
library(knitr)
```

\vspace{1cm}

# Introduction 

Dans ce projet on s'interesse à la poulation des gènes d'une plante modèle
On souhaite réaliser une analyse descriptive de ce jeu de données.

# Statistique déscriptive

## Description des données 

Afin de décrire l’ensemble du jeu de donnees nous avons utlisé quelques commandes de R {\textbf{\textsf{R}}}

```{r,debut,echo=FALSE,results="hide"}
data1<-read.table("DataProjet3MIC-2425.txt",header=T,sep = ";")
#commande pour l'analyse du jeu de données 
head(data1)
summary(data1)
str(data1)
```



Dans ce jeu de données, on observe un échantillon G=542 gènes d'une plante modèle. Ici, notre individu est le gène.

Ces individus sont representés par 39 variables statistiques : 

- les mesures des différences d'expression des gènes (la différence d'expression d'un gène g pour un traitement appliqué (T1,T2,T3) en comparaison d'un état sans          traitement de référence), que l'on observe en 6 temps différents (1h, 2h, 3h, 4h, 5h, 6h) pour deux réplicats biologiques 
  Ces variables sont de la forme Tt_sh_Rr et sont des variables quantitatives continues.
  
- une variable détermine, pour chaque traitement si le gène est sur-exprimé, sous-exprimé, ou non-exprimé ("sur", "sous", "non").
  Ces variables sont de la forme ExpT(1,2,3) et sont qualitatives nominales prenant les modalités "sur","sous" et "non"

Afin de visualiser les données, les premiers individus du jeu de données sont affichées dans la Table \ref{tab:tabdata1}.

Au vu du grand nombre de données nous avons décidé de représenter seulement les variables T1_1h_R1 à T1_6h_R1 et ExpT1 qui donnent un aperçu de la structure du jeu de données.

```{r,echo=FALSE}
#Tableau avec les premiere ligne du jeu de données 
kable(head(data1[,c(1:6,37)]),caption="\\label{tab:tabdata1}Les premières lignes du jeu de données.")
```

## Anlayse uni-dimensionnelle

### Variables qualitatives (ici ExpT1 ExpT2 ExpT3)

```{r,echo=FALSE,results="hide",message = FALSE, warning = FALSE}
#permet de préciser à R les variables qui doivent être considérées comme qualitatives. On utilise donc la fonction `as.factor()
data1$ExpT1<-as.factor(data1$ExpT1)
data1$ExpT2<-as.factor(data1$ExpT2)
data1$ExpT3<-as.factor(data1$ExpT3)

#resumé de la variable ExpT1
table(data1$ExpT1)
levels(data1$ExpT1)

#resumé de la variable ExpT2
table(data1$ExpT2)
levels(data1$ExpT2)

#resumé de la variable ExpT3
table(data1$ExpT3)
levels(data1$ExpT3)
```
```{r}
#Commenter 

Eff1<-table(data1$ExpT1)
df<-data.frame(Eff=c(Eff1),Freq=c(Eff1)/sum(Eff1))
#knitr::kable(t(df))
Eff2<-table(data1$ExpT2)
df<-data.frame(Eff=c(Eff2),Freq=c(Eff2)/sum(Eff2))
#knitr::kable(t(df))
Eff3<-table(data1$ExpT3)
df<-data.frame(Eff=c(Eff3),Freq=c(Eff3)/sum(Eff3))
#knitr::kable(t(df))
df<-data.frame(ExpT1=c(Eff1)*100/sum(Eff1),ExpT2=c(Eff2)*100/sum(Eff2),ExpT3=c(Eff3)*100/sum(Eff3))
knitr::kable(t(df),caption="\\label{tab:tabfréquence} Fréquences en pourcentage des variables ExpT1, ExpT2, ExpT3")


```

```{r,echo=FALSE,results="hide",message = FALSE, warning = FALSE,fig.show = "hide"}
#Variables ExpT1 

g1<-ggplot(data1, aes(x=ExpT1))+ 
  geom_bar()+
  ylab("")+ggtitle("Effectifs")
g2<-ggplot(data1, aes(x = ExpT1)) +  
  geom_bar(aes(y = (..count..)/sum(..count..)))+ylab("")+ggtitle("Frequences")

df <- data.frame(group = levels(data1$ExpT1),value = as.vector(table(data1$ExpT1))/nrow(data1))
g3<-ggplot(df, aes(x="", y=value, fill=group))+
  geom_bar(width = 1, stat = "identity")+ 
  coord_polar("y", start=0)+ 
  theme(legend.position="bottom")
grid.arrange(g3,g1,g2,ncol=3)
```


```{r,echo=FALSE,results="hide",message = FALSE, warning = FALSE,fig.show = "hide"}

#Variables ExpT2 

g1<-ggplot(data1, aes(x = ExpT2))+ 
  geom_bar()+
  ylab("")+ggtitle("Effectifs")
g2<-ggplot(data1, aes(x = ExpT2)) +  
  geom_bar(aes(y = (..count..)/sum(..count..)))+ylab("")+ggtitle("Frequences")

df <- data.frame(group = levels(data1$ExpT2),
                 value = as.vector(table(data1$ExpT2))/nrow(data1))
g3<-ggplot(df, aes(x="", y=value, fill=group))+
  geom_bar(width = 1, stat = "identity")+ 
  coord_polar("y", start=0)+ 
  theme(legend.position="bottom")
grid.arrange(g3,g1,g2,ncol=3)

```


```{r,fig.show = "hide"}

#Variables ExpT3 

g1<-ggplot(data1, aes(x = ExpT3))+ 
  geom_bar()+
  ylab("")+ggtitle("Effectifs")
g2<-ggplot(data1, aes(x = ExpT3)) +  
  geom_bar(aes(y = (..count..)/sum(..count..)))+ylab("")+ggtitle("Frequences")

df <- data.frame(group = levels(data1$ExpT3),
                 value = as.vector(table(data1$ExpT3))/nrow(data1))
g3<-ggplot(df, aes(x="", y=value, fill=group))+
  geom_bar(width = 1, stat = "identity")+ 
  coord_polar("y", start=0)+ 
  theme(legend.position="bottom")
grid.arrange(g3,g1,g2,ncol=3)

```
Résumé 

```{r,fig.cap="\\label{fig:Barplots}Barplots des variables qualitative ExpT1, ExpT2, ExpT3"}
g1<-ggplot(data1, aes(x = ExpT1)) +  geom_bar(aes(y = (..count..)/sum(..count..)))+ylab("")+ggtitle("Frequences")
g2<-ggplot(data1, aes(x = ExpT2)) +  geom_bar(aes(y = (..count..)/sum(..count..)))+ylab("")+ggtitle("Frequences")
g3<-ggplot(data1, aes(x = ExpT3)) +  geom_bar(aes(y = (..count..)/sum(..count..)))+ylab("")+ggtitle("Frequences")
grid.arrange(g1,g2,g3,ncol=3)
```

### Variables quantitatives 
1. histogramme (les 2 manières)
2. Moyenne empirique 
3.variances et écart types 
  pas forcement utile mais il faut mieux le faire
4.Boxplot (faire un avec tout les varaibles du replicat 1 puis faire avec les variables du replicat 2)
  Mise en page voir photo dans téléphone

Boxplot 

```{r boxplot1,fig.cap="\\label{fig:BoxplotR1}Boxplot du réplicat 1 (R1)"}
 data1aux<-melt(data1[,-c(19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39)])
ggplot(data1aux,aes(x=variable,y=value))+geom_boxplot()+ theme(plot.margin = unit(c(0, 0, 0, 0), "cm"))

```


```{r boxplot2,fig.cap=" Boxplot du réplicat 2 (R2)"}
 data1auxR2<-melt(data1[,-c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,37,38,39)])
 ggplot(data1auxR2,aes(x=variable,y=value))+geom_boxplot()+ theme(plot.margin = unit(c(0, 0, 0, 0), "cm"))

```

Faire une analyse des boxplots et comparer le replicat 1 et 2 

## Analyse bi-dimentionnelle 

Une attention particulière sera portée sur le choix des représentations, et sur l’interprétation des résultats présentés.

```{r}

```


### 2 variables quantitatives 
Commencer par faire un diagramme de corrélation entre les variables quantitative pour savoir lesquelles etudier 2 à 2 

```{r,fig.cap="\\label{fig:Corrélation} Matrice des corrélations"}
data <- data1[, 1:(ncol(data1) - 3)]
mcor <- cor(data)
corrplot(mcor, method = "ellipse") 

```

pas lisible trouver un moyen de le rendre lisible ( peut etre en resortant les carrés que l'on voit qui sont fortement corrélés )

```{r,eval=FALSE,fig.show = "hide"}
data <- data1[,-c(19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39)]
mcor <- cor(data)
corrplot(mcor, method = "ellipse", title = "Matrice 2") 
data1[,-c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,37,38,39)]
mcor <- cor(data)
corrplot(mcor, method = "ellipse", title = "Matrice 3")

```


1. Nuage de points 
2. Covariance
3. Corrélation 
4. Regression linéaire

```{r,eval=FALSE,fig.show = "hide"}
#analyse bi dimensionnelle pour deux variables avec une fort corélation
var1 <- data1$T2_2H_R1
var2 <- data1$T2_3H_R1
ggplot(data1, aes(x=var1,y=var2))+
  geom_point(size=2)
cor(var1,var2)
var(var1,var2)

ggplot(data1, aes(x= var1, y = var2))+geom_point(color="blue", alpha=0.2)+geom_smooth(method="lm")

```
```{r,eval=FALSE,fig.show = "hide"}
#analyse d'un deuxième point 
var1 <- data1$T1_5H_R2
var2 <- data1$T1_6H_R2
ggplot(data1, aes(x=var1,y=var2))+
  geom_point(size=2)
cor(var1,var2)
var(var1,var2)

ggplot(data1, aes(x= var1, y = var2))+geom_point(color="blue", alpha=0.2)+geom_smooth(method="lm")
```
```{r,eval=FALSE,fig.show = "hide"}
#avec deux points qui ne semblent pas corrélés
var1 <- data1$T1_1H_R1
var2 <- data1$T2_6H_R1
ggplot(data1, aes(x=var1,y=var2))+
  geom_point(size=2)
cor(var1,var2)
var(var1,var2)

ggplot(data1, aes(x= var1, y = var2))+geom_point(color="blue", alpha=0.2)+geom_smooth(method="lm")
```
```{r}
#résultats cohérents
```



### 1 variable quantitative et 1 qualitative

1. Représentation graphique : boxplots parallèles
Plus les boxplot sont “diférents”, plus X et Y sont liés
ATTENTION 1 VARIABLE QUALITATIVE ET 1 VARIABLE QUANTITATIVE SONT LIES PAS CORRELEE !!!!!!!
2. Carré du rapport de corrélation empirique 
si proche de 0 X et Y ne sont pas liées 
si proche de 1 X et Y sont liées 

```{r,fig.cap="\\label{fig:boxplots}Différents boxplots entre 1 variable quantitative et 1 variable qualitative"}
g1<-ggplot(data=data1,aes(x=ExpT1,y=T1_6H_R1 ))+geom_boxplot()
g2<-ggplot(data=data1,aes(x=ExpT2,y=T2_6H_R1))+geom_boxplot()
g3<-ggplot(data=data1,aes(x=ExpT3,y=T3_6H_R1 ))+geom_boxplot()
g4<-ggplot(data=data1,aes(x=ExpT1,y=T1_6H_R2 ))+geom_boxplot()
g5<-ggplot(data=data1,aes(x=ExpT2,y=T2_6H_R2))+geom_boxplot()
g6<-ggplot(data=data1,aes(x=ExpT3,y=T3_6H_R2 ))+geom_boxplot()

grid.arrange(g1,g2,g3,g4,g5,g6,ncol=6)
#on prend T3 car combinaison de traitements de T1 et de T2, et à 6h car expT1,T2,T2 sont des résultats que l'on connait à 6H. Puis on trace les boxplots des deux réplicats.
```
```{r}
#Ne fonctionne pas à corriger 
#eta2(x=Données$ExpT1,y=Données$T3_6H_R1)
#eta2(x=Données$ExpT2,y=Données$T3_6H_R1)
#eta2(x=Données$ExpT3,y=Données$T3_6H_R1)
#eta2(x=Données$ExpT1,y=Données$T3_6H_R2)
#eta2(x=Données$ExpT2,y=Données$T3_6H_R2)
#eta2(x=Données$ExpT3,y=Données$T3_6H_R2)
#v<-NULL
#for (i in 1:6){
 # v <-c(v,eta2(Données[,i+2],Données[,2]))
#}
#v
#apply(données[,-c(1,2)],2,function(x){eta2(x,Données$ExpT1)})
```


### 2 variables qualitatives 
1. Tableau de contingence 
2. Mosaic plot 
3. Indice de liaison 

```{r,fig.cap="\\label{fig:boxplots} Tableaux de contingence des variables qualitatives"}
#prop.table(table(var1,var2),margin=1)
g1<-ggplot(data1,aes(x=ExpT1,fill=ExpT2))+
geom_bar(position = "fill")
#prop.table(table(var1,var3),margin=1)
g2<-ggplot(data1,aes(x=ExpT1,fill=ExpT3))+
geom_bar(position = "fill")
#prop.table(table(var2,var3),margin=1)
g3<-ggplot(data1,aes(x=ExpT2,fill=ExpT3))+
geom_bar(position = "fill")
grid.arrange(g1,g2,g3,ncol=3)
#mosaicplot(table(var1,var2))
#mosaicplot(table(var1,var3))
#mosaicplot(table(var2,var3))
```








# Analyse des Tt_sH_Rr :
## Analyse en composantes principales 
Menez une analyse en composantes principales où les Tt sH Rr sont les individus décrits par les gènes.
ACP inversé 
```{r}

#on retire les variables qalitatives parce que autrement cela rentre dans les variables vu que l'on transpose 
data1ACP1 <- t(data1[,-c(37,38,39)])
dim(data1ACP1)
#36 individus et 542 variables on a bien transposé le dataframe original 

#ACP Centrée
respca<-PCA(data1ACP1,scale.unit=F,graph=F) #ACP Centrée pour comparer les variances avec ACP centrée réduite et choisir le modèle
respca$eig[1:2, ]

```

```{r, fig.cap="Histogramme après acp"}
#pas de qualisup car pas de variable qualitative 
respca<-PCA(data1ACP1,scale.unit=T,graph=F)
respca$eig[1:2, ]
```


```{r, fig.cap="Histogramme après acp"}
fviz_eig(respca)

``` 
  
  
  
  
  
```{r,fig.cap="\\label{fig:boxplots} Bilan ACP"}
g1<-fviz_pca_ind(respca,geom=c("point"))
g2<-fviz_pca_var(respca)
grid.arrange(g1,g2,ncol=2)

```



## Clustering 

il faut d'abord faire une analyse pour savoir combien de classes prendre

évolution de l'inertie intraclasse

```{r, fig.cap="Recherche de notre K (analyse k means)"}
#commenter pourquoi on reduit et centre les données 

data1ACP1C<-scale(x=data1ACP1 ,center=TRUE,scale=TRUE)

#Inertie intraclasse

Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(data1ACP1),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
  resaux<-kmeans(data1ACP1C,k)
  reskmeanscl[,k-1]<-resaux$cluster
  Iintra<-c(Iintra,resaux$tot.withinss)
}

df<-data.frame(K=2:15,Iintra=Iintra)
g1<-ggplot(df,aes(x=K,y=Iintra))+
  geom_line()+
  geom_point()+
  xlab("Nombre de classes")+
  ylab("Inertie intraclasse") 
  #ggtitle("Figure 9.1: Inertie intraclasse")


#silhouette

Silhou<-NULL
for (k in 2:Kmax){
   aux<-silhouette(reskmeanscl[,k-1], daisy(data1ACP1C))
   Silhou<-c(Silhou,mean(aux[,3]))
}

df<-data.frame(K=2:Kmax,Silhouette=Silhou)
g2<-ggplot(df,aes(x=K,y=Silhouette))+
  geom_point()+
  geom_line()+theme(legend.position = "bottom")
# ggtitle("Figure 10 : Coefficients silhouette")

aux<-silhouette(reskmeanscl[,2],daisy(data1ACP1C))
g3<-fviz_silhouette(aux)+
  theme(plot.title = element_text(size =9)) 
#+ ggtitle("Figure 11 : Visualisation des silhouettes")
rm(df,Silhou,aux)

g1 <- g1 + ggtitle("Figure 9.1: Inertie intraclasse") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))
g2 <- g2 + ggtitle("Figure 9.2: Coefficients silhouettes") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))
g3 <- g3 + ggtitle("Figure 9.3 : Visualisation des silhouettes") + theme(plot.title = element_text(hjust = 0.5, vjust = 2))

grid.arrange(g1,g2,g3,ncol=3)

```






On peut observer un coude à K=3 

Faire d'autres méthodes de determination du nombre de classes pour vérifier K=3 


Ici Kmeans avec K=3 



```{r, fig.cap="Nuées dynamiques"}

data1ACP1C<-scale(x=data1ACP1 ,center=TRUE,scale=TRUE)
reskmeans<-kmeans(data1ACP1C,3)
#fviz_pca_ind(respca,habillage=as.factor(reskmeans$cluster) ,geom=c("point"))
#table(reskmeans$cluster)
fviz_cluster(reskmeans,data=data1ACP1C,
             ellipse.type="norm",labelsize=8,
             geom=c("point"))+ggtitle("")

```






Il faut regarder ce qu'il y a dans reskmeans$cluster pour voir qu'elle variable va dans quelle classe et commenter 

On ne compare pas avec les variables qualitatives car il n'y en a pas 

Classification hiérarchique
```{r}
dist_data1ACP1 = dist(data1ACP1)
#hclustsingle<-hclust(dist_data1ACP1, method = "single")
#hclustcomplete<-hclust(dist_data1ACP1, method = "complete")
#hclustaverage<-hclust(dist_data1ACP1, method = "average" )

# Dendrogramme
#plot(hclustsingle,hang=-1,labels=FALSE)

#fviz_dend(hclustsingle,show_labels=FALSE)
```
```{r}
# dendogramme
#tree <- hclustcomplete<-hclust(dist_data1ACP1, method = "complete")
#ClassK3 <- cutree(tree, k=3 )
#df<-data.frame(data1ACP1,Class=as.factor(ClassK3))
#df<-melt(df,id="Class")
#ggplot(df,aes(x=variable,y=value))+geom_boxplot(aes(fill=Class))
```
**Question :** Dans cette question et pour les suivantes, on se focalise sur la mesure d'agrégation de Ward. Ajustez une classification hiérarchique avec la mesure de Ward. Que représentent les hauteurs du dendrogramme dans ce cas ? 
```{r,fig.height=6,fig.width=15,fig.align = "center", fig.cap="Dendrogramme"}
# dendogramme
hward<-hclust(dist_data1ACP1, method = "ward.D2") 
fviz_dend(hward,show_labels=FALSE)
```
**Question : ** Déterminez le nombre de classes à retenir avec l'indice de Calinski-Harabasz. Vous pouvez vous aider de la fonction `ìndex.G1()` de la librairie `clusterSim`. Tracez la classification obtenue sur le dendrogramme et sur le premier plan factoriel de l'ACP. 

```{r ,fig.cap="A compléter v"}
# A completer
CH<-NULL
Kmax<-20
for (k in 2:Kmax){
  CH<-c(CH,index.G1(data1ACP1, cl= cutree(hward,k)))
}
#On prend k = 3
daux<-data.frame(NbClust=2:Kmax,CH=CH)
g1<-ggplot(daux,aes(x=NbClust,y=CH))+
  geom_line()+
  geom_point()

ClustCH<-cutree(hward,k=3)
g2<-fviz_dend(hward, show_labels = FALSE, k = 3)
g3<-fviz_pca_ind(respca, geom = c("point"), habillage = as.factor(ClustCH)) 

grid.arrange(g1,g2,g3,ncol=3)
```



# Analyse des gènes : 

## Jeu de données DataExpMoy 
Construisez un jeu de données DataExpMoy contenant la moyenne des expressions sur les réplicats de chaque gène, pour chaque traitement et chaque heure. DataExpMoy est donc une matrice de taille G × 18. Vous pourrez utiliser les variables ExpT1, ExpT2 et ExpT3 pour commenter vos résultats des questions suivantes.



```{r}
data1R1 <- data1[,1:18]
data1R2 <- data1[,19:36]
data1ACP2 <-( data1R1 + data1R2 ) /2
#DonnéesACP2 <- Données[,-c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18)]
dim(data1ACP2)
#on ajoute les variables qualitatives 
data1ACP2 <- cbind(data1ACP2, ExpT1 = data1$ExpT1, ExpT2 = data1$ExpT2, ExpT3 = data1$ExpT3)
dim(data1ACP2)
```

## Analyse en composantes principales 
Menez une analyse en composantes principales pour les gènes à partir du jeu de données DataExpMoy.
   
   
   
```{r,fig.cap="A compléter b"}
respca2<-PCA(data1ACP2,quali.sup=c(19,20,21), scale.unit=T,graph=F)
respca2$eig[1:2, ]
fviz_eig(respca2)
#corrélations des variables intiales avec toutes les méta-variables
corrplot(respca2$var$cor,method="ellipse")

```









```{r,fig.cap="A compléter g"}
g1<-fviz_pca_ind(respca2,geom=c("point"))
g2<-fviz_pca_var(respca2)
grid.arrange(g1,g2,ncol=2)

```

## Clustering 1 
Faites une classification non supervisée (clustering) des gènes à partir de leur expression (DataExpMoy) afin d’obtenir des classes de gènes homogènes (ayant la même evolution d’expression).

```{r, fig.cap="A compléter r"}
data1ACP2C<-scale(data1ACP2[,-c(19,20,21)] ,center=TRUE,scale=TRUE)

```
  
  
  
```{r, fig.cap="A compléter d"}
Kmax<-15
reskmeanscl<-matrix(0,nrow=nrow(data1ACP2),ncol=Kmax-1)
Iintra<-NULL
for (k in 2:Kmax){
  resaux<-kmeans(data1ACP2C,k)
  reskmeanscl[,k-1]<-resaux$cluster
  Iintra<-c(Iintra,resaux$tot.withinss)
}

df<-data.frame(K=2:15,Iintra=Iintra)
g1<-ggplot(df,aes(x=K,y=Iintra))+
  geom_line()+
  geom_point()+
  xlab("Nombre de classes")+
  ylab("Inertie intraclasse")

# Silhouette 

Silhou<-NULL
for (k in 2:Kmax){
   aux<-silhouette(reskmeanscl[,k-1], daisy(data1ACP2C))
   Silhou<-c(Silhou,mean(aux[,3]))
}

df<-data.frame(K=2:Kmax,Silhouette=Silhou)
g2<-ggplot(df,aes(x=K,y=Silhouette))+
  geom_point()+
  geom_line()+theme(legend.position = "bottom")
```
    
    
    
    

```{r, fig.cap="A compléter h"}
aux<-silhouette(reskmeanscl[,3],daisy(data1ACP2C))
g3<-fviz_silhouette(aux)+
  theme(plot.title = element_text(size =9))
rm(df,Silhou,aux)


grid.arrange(g1,g2,g3,ncol=3)
```


On peut observer un coude à K=3 

Faire d'autres méthodes de determination du nombre de classes pour vérifier K=3 

```{r, fig.cap="A compléter e"}
reskmeans<-kmeans(data1ACP2C,3)
#fviz_pca_ind(respca2,habillage=as.factor(reskmeans$cluster) ,geom=c("point"))
#table(reskmeans$cluster)
fviz_cluster(reskmeans,data=data1ACP2C,
             ellipse.type="norm",labelsize=8,
             geom=c("point"))+ggtitle("")
g1<-fviz_pca_ind(respca2,habillage="ExpT1",geom=c("point"))
g2<-fviz_pca_ind(respca2,habillage="ExpT2",geom=c("point"))
g3<-fviz_pca_ind(respca2,habillage="ExpT3",geom=c("point"))
grid.arrange(g1,g2,g3,ncol=3)


```



Faire d'autres clustering que les kmeans 

```{r, fig.cap="A compléter y"}
clust<-paste("Cl-K",reskmeans$cluster,sep="")
Tab<-melt(table(clust,data1ACP2[,19]))
g1<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("Figure 15.3")+
  theme(legend.position = "none")
#chordDiagram(table(clust,data1ACP2[,19]))
#clust<-paste("Cl-K",reskmeans$cluster,sep="")
```


```{r, fig.cap="A compléter h"}
clust<-paste("Cl-K",reskmeans$cluster,sep="")
Tab<-melt(table(clust,data1ACP2[,20]))
g2<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure15.1 a completer")
  theme(legend.position = "none")
#chordDiagram(table(clust,data1ACP2[,20]))
#clust<-paste("Cl-K",reskmeans$cluster,sep="")
```




```{r, fig.cap="A compléter k"}
clust<-paste("Cl-K",reskmeans$cluster,sep="")
Tab<-melt(table(clust,data1ACP2[,21]))
g3<-ggplot(Tab,aes(y=value,axis1=clust,axis2=Var2))+
  geom_alluvium(aes(fill=clust))+
  geom_stratum(width = 1/12)+   
  geom_text(stat = "stratum", aes(label = after_stat(stratum)))+
  ggtitle("figure 15.2")
  theme(legend.position = "none")
#chordDiagram(table(clust,data1ACP2[,21]))
#clust<-paste("Cl-K",reskmeans$cluster,sep="")
grid.arrange(g1,g2,g3,ncol=3)
```
 
 
 


Faire d'autres clustering que les kmeans 
Classification hiérarchique
```{r, fig.cap="A compléter e"}
dist_data1ACP2 = dist(data1ACP2)
#hclustsingle<-hclust(dist_data1ACP2, method = "single")
#hclustcomplete<-hclust(dist_data1ACP2, method = "complete")
#hclustaverage<-hclust(dist_data1ACP2, method = "average" )

# Dendrogramme
#plot(hclustsingle,hang=-1,labels=FALSE)

#fviz_dend(hclustsingle,show_labels=FALSE)
```




```{r,fig.align = "center"}
hward<-hclust(dist_data1ACP2, method = "ward.D2") 
fviz_dend(hward,show_labels=FALSE)
```

```{r}
CH<-NULL
Kmax<-20
for (k in 2:Kmax){
  CH<-c(CH,index.G1(data1ACP2C, cl= cutree(hward,k)))
}
#On prend k = 3
daux<-data.frame(NbClust=2:Kmax,CH=CH)
g1<-ggplot(daux,aes(x=NbClust,y=CH))+
  geom_line()+
  geom_point()

ClustCH<-cutree(hward,k=3)
g2<-fviz_dend(hward, show_labels = FALSE, k = 3)
g3<-fviz_pca_ind(respca2, geom = c("point"), habillage = as.factor(ClustCH))
grid.arrange(g1,g2,g3,ncol=3)

```
## Clustering 2 
Faites une classification non supervisée (clustering) des gènes à partir des variables ExpT1, ExpT2 et ExpT3. Comparez avec les résultats de la question précédente

```{r}

```
